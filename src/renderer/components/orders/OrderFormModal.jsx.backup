// src/renderer/components/orders/OrderFormModal.jsx
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import Modal from "../common/Modal";
import CustomerFormModal from "../people/CustomerFormModal";
import { lookupCep } from "../clients/utils";
import { emitToast } from "../../utils/toast";
import { normalizeProductsCollections } from "../../utils/normalizeProductsCollections";
import MapLink, { DeliveryInfo } from "../common/MapLink";
import { OrderIcon } from "./OrderIcons";

// Import new modular components
import OrderItemsModal from "./modals/OrderItemsModal";
import CustomerInfoModal from "./modals/CustomerInfoModal";
import DeliveryAddressModal from "./modals/DeliveryAddressModal";
import OrderStatusModal from "./modals/OrderStatusModal";
import OrderSummaryModal from "./modals/OrderSummaryModal";
import PaymentModal from "./modals/PaymentModal";
import OrderOptionsModal from "./modals/OrderOptionsModal";
import CustomerHistoryModal from "./modals/CustomerHistoryModal";

function InfoIcon({ text }) {
  if (!text) return null;
  return (
    <span className="info-icon" data-tooltip={text} aria-label={text}>
      i
    </span>
  );
}

function digitsOnly(s) {
  return (s || "").replace(/\D/g, "");
}

async function lookupCepByAddress({ street, city, state }) {
  if (!street || !city || !state) {
    throw new Error("Endereço incompleto para buscar CEP.");
  }
  const url = `https://viacep.com.br/ws/${encodeURIComponent(
    state
  )}/${encodeURIComponent(city)}/${encodeURIComponent(street)}/json/`;
  const res = await fetch(url);
  if (!res.ok) {
    throw new Error("Erro ao consultar CEP.");
  }
  const data = await res.json();
  if (!Array.isArray(data) || data.length === 0 || data.erro) {
    throw new Error("CEP não encontrado.");
  }
  const first = data[0] || {};
  return {
    cep: digitsOnly(first.cep || ""),
    street: first.logradouro || "",
    neighborhood: first.bairro || "",
    city: first.localidade || city,
    state: first.uf || state,
  };
}

async function retryLookup(lookupFn, { retries = 2, delayMs = 800 } = {}) {
  let lastError = null;
  for (let attempt = 0; attempt <= retries; attempt += 1) {
    try {
      return await lookupFn();
    } catch (err) {
      lastError = err;
      if (attempt >= retries) break;
      await new Promise((resolve) => setTimeout(resolve, delayMs));
    }
  }
  throw lastError;
}

function normalizeNeighborhoodKey(value) {
  if (!value) return "";
  return value
    .toString()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .trim()
    .toLowerCase();
}

function findBlockedNeighborhood(neighborhood, blockedList) {
  if (!neighborhood || !Array.isArray(blockedList)) return null;
  const key = normalizeNeighborhoodKey(neighborhood);
  if (!key) return null;
  return (
    blockedList.find(
      (item) => normalizeNeighborhoodKey(item) === key
    ) || null
  );
}

const ORDER_DRAFT_STORAGE_KEY = "orderDraftV1";

function normalizeAddressParts(address, neighborhoodOverride) {
  const addr = address || {};
  return {
    cep: addr.cep || addr.CEP || "",
    street: addr.street || addr.rua || "",
    number: addr.number || addr.numero || "",
    neighborhood: neighborhoodOverride || addr.neighborhood || addr.bairro || "",
    city: addr.city || addr.cidade || "",
    state: addr.state || addr.uf || "",
  };
}

function getMissingAddressFields(address, neighborhoodOverride) {
  const missing = [];
  const addr = normalizeAddressParts(address, neighborhoodOverride);
  if (!addr.street) missing.push("Rua");
  if (!addr.number) missing.push("Número");
  if (!addr.neighborhood) missing.push("Bairro");
  if (!addr.city) missing.push("Cidade");
  if (!addr.state) missing.push("Estado");
  return missing;
}

function createEmptyAltAddress() {
  return {
    id: "",
    label: "",
    cep: "",
    street: "",
    number: "",
    complement: "",
    neighborhood: "",
    city: "",
    state: "",
    reference: "",
  };
}

/**
 * Endereço base fixo da pizzaria
 * Usado para calcular a distância até o cliente.
 */
const BASE_DELIVERY_ADDRESS =
  "Rua Dona Elfrida, 719 - Santa Teresinha, São Paulo - SP";

/**
 * Tabela padrão de entrega por km (fallback caso não exista em settings)
 */
const DEFAULT_DELIVERY_CONFIG = {
  baseLocationLabel: "Rua Dona Elfrida, 719 - Santa Teresinha",
  blockedNeighborhoods: [],
  minOrderValue: 0,
  maxDistanceKm: 0,
  etaMinutesDefault: 45,
  peakFee: {
    enabled: false,
    days: [],
    startTime: "18:00",
    endTime: "22:00",
    amount: 0,
  },
  ranges: [
    {
      id: "r0_0_8",
      label: "até 0,8 km",
      minKm: 0,
      maxKm: 0.8,
      price: 3.5,
    },
    {
      id: "r0_81_1_5",
      label: "0,81 a 1,5 km",
      minKm: 0.81,
      maxKm: 1.5,
      price: 5.9,
    },
    {
      id: "r1_6_2",
      label: "de 1,6 a 2,0 km",
      minKm: 1.6,
      maxKm: 2.0,
      price: 7.5,
    },
    {
      id: "r2_1_4",
      label: "de 2,1 a 4,0 km",
      minKm: 2.1,
      maxKm: 4.0,
      price: 8.9,
    },
    {
      id: "r4_1_5_5",
      label: "de 4,1 a 5,5 km",
      minKm: 4.1,
      maxKm: 5.5,
      price: 10.9,
    },
    {
      id: "r5_6_9",
      label: "de 5,6 a 9,0 km",
      minKm: 5.6,
      maxKm: 9.0,
      price: 12.9,
    },
    {
      id: "r9_1_11_5",
      label: "de 9,1 a 11,5 km",
      minKm: 9.1,
      maxKm: 11.5,
      price: 18.0,
    },
    {
      id: "r11_6_15",
      label: "de 11,6 a 15,0 km",
      minKm: 11.6,
      maxKm: 15.0,
      price: 22.0,
    },
    {
      id: "pickup",
      label: "Retirar / até 0,1 km",
      minKm: 0,
      maxKm: 0.1,
      price: 0.0,
    },
  ],
};

function buildWeeklySchedule(
  openTime = "11:00",
  closeTime = "23:00",
  closedWeekdays = []
) {
  const closed = Array.isArray(closedWeekdays) ? closedWeekdays : [];
  return [0, 1, 2, 3, 4, 5, 6].map((day) => ({
    day,
    enabled: !closed.includes(day),
    openTime,
    closeTime,
  }));
}

const DEFAULT_BUSINESS_HOURS = {
  enabled: false,
  openTime: "11:00",
  closeTime: "23:00",
  closedWeekdays: [],
  weeklySchedule: buildWeeklySchedule(),
};

/**
 * Normaliza deliveryConfig vindo de settings (caso exista)
 */
function normalizeDeliveryConfigFromSettings(rawSettings) {
  if (!rawSettings) return DEFAULT_DELIVERY_CONFIG;

  let settingsObj = null;
  if (Array.isArray(rawSettings.items) && rawSettings.items.length > 0) {
    settingsObj = rawSettings.items[0];
  } else if (Array.isArray(rawSettings) && rawSettings && rawSettings.length > 0) {
    settingsObj = rawSettings[0];
  } else if (typeof rawSettings === "object") {
    settingsObj = rawSettings;
  }

  const delivery = settingsObj.delivery;
  if (!delivery || !Array.isArray(delivery.ranges)) {
    return DEFAULT_DELIVERY_CONFIG;
  }

  return {
    baseLocationLabel:
      delivery.baseLocationLabel ||
      DEFAULT_DELIVERY_CONFIG.baseLocationLabel,
    minOrderValue:
      typeof delivery.minOrderValue === "number"
        ? delivery.minOrderValue
        : Number(delivery.minOrderValue || 0),
    maxDistanceKm:
      typeof delivery.maxDistanceKm === "number"
        ? delivery.maxDistanceKm
        : Number(delivery.maxDistanceKm || 0),
    etaMinutesDefault:
      typeof delivery.etaMinutesDefault === "number"
        ? delivery.etaMinutesDefault
        : Number(delivery.etaMinutesDefault || 45),
    blockedNeighborhoods: Array.isArray(delivery.blockedNeighborhoods)
      ? delivery.blockedNeighborhoods
          .map((b) => (b || "").toString().trim())
          .filter(Boolean)
      : [],
    peakFee: {
      enabled: !!delivery.peakFee.enabled,
      days: Array.isArray(delivery.peakFee.days)
        ? delivery.peakFee.days
        : [],
      startTime: delivery.peakFee.startTime || "18:00",
      endTime: delivery.peakFee.endTime || "22:00",
      amount:
        typeof delivery.peakFee.amount === "number"
          ? delivery.peakFee.amount
          : Number(delivery.peakFee.amount || 0),
    },
    ranges: delivery.ranges.map((r, idx) => ({
      id: r.id || `r_${idx}`,
      label:
        r.label ||
        DEFAULT_DELIVERY_CONFIG.ranges[idx].label ||
        `Faixa ${idx + 1}`,
      minKm:
        typeof r.minKm === "number"
          ? r.minKm
          : Number(r.minKm || DEFAULT_DELIVERY_CONFIG.ranges[idx].minKm || 0),
      maxKm:
        typeof r.maxKm === "number"
          ? r.maxKm
          : Number(r.maxKm || DEFAULT_DELIVERY_CONFIG.ranges[idx].maxKm || 0),
      price:
        typeof r.price === "number"
          ? r.price
          : Number(r.price || DEFAULT_DELIVERY_CONFIG.ranges[idx].price || 0),
    })),
  };
}

function normalizeBusinessHoursFromSettings(rawSettings) {
  if (!rawSettings) return DEFAULT_BUSINESS_HOURS;

  let settingsObj = null;
  if (Array.isArray(rawSettings.items) && rawSettings.items.length > 0) {
    settingsObj = rawSettings.items[0];
  } else if (Array.isArray(rawSettings) && rawSettings && rawSettings.length > 0) {
    settingsObj = rawSettings[0];
  } else if (typeof rawSettings === "object") {
    settingsObj = rawSettings;
  }

  const hours = settingsObj.businessHours || {};
  const openTime = hours.openTime || DEFAULT_BUSINESS_HOURS.openTime;
  const closeTime = hours.closeTime || DEFAULT_BUSINESS_HOURS.closeTime;
  const closedWeekdays = Array.isArray(hours.closedWeekdays)
    ? hours.closedWeekdays
    : [];
  const baseSchedule = buildWeeklySchedule(
    openTime,
    closeTime,
    closedWeekdays
  );
  const rawSchedule = Array.isArray(hours.weeklySchedule)
    ? hours.weeklySchedule
    : null;
  const weeklySchedule = rawSchedule
    ? baseSchedule.map((entry) => {
        const match = rawSchedule.find(
          (item) => Number(item.day) === entry.day
        );
        if (!match) return entry;
        return {
          ...entry,
          enabled: match.enabled !== false,
          openTime: match.openTime || entry.openTime,
          closeTime: match.closeTime || entry.closeTime,
        };
      })
    : baseSchedule;
  const normalizedClosed = weeklySchedule
    .filter((entry) => entry.enabled === false)
    .map((entry) => entry.day);

  return {
    enabled: !!hours.enabled,
    openTime,
    closeTime,
    closedWeekdays: normalizedClosed,
    weeklySchedule,
  };
}

/**
 * Converte string "1,5" ou "1.5" para número
 */
function parseKmValue(value) {
  if (value === null || value === undefined || value === "") return 0;
  const normalized = String(value).replace(",", ".");
  const n = Number(normalized);
  return Number.isNaN(n) ? 0 : n;
}

function parseTimeToMinutes(value) {
  if (!value || typeof value !== "string") return null;
  const [h, m] = value.split(":").map((part) => Number(part));
  if (Number.isNaN(h) || Number.isNaN(m)) return null;
  return h * 60 + m;
}

function isWithinTimeRange(nowMinutes, startMinutes, endMinutes) {
  if (startMinutes === null || endMinutes === null) return true;
  if (startMinutes === endMinutes) return true;
  if (endMinutes > startMinutes) {
    return nowMinutes >= startMinutes && nowMinutes <= endMinutes;
  }
  return nowMinutes >= startMinutes || nowMinutes <= endMinutes;
}

function getBusinessHoursStatus(businessHours, date = new Date()) {
  if (!businessHours.enabled) return { isOpen: true, reason: "" };

  const weekday = date.getDay();
  const closed = Array.isArray(businessHours.closedWeekdays)
    ? businessHours.closedWeekdays
    : [];
  const schedule = Array.isArray(businessHours.weeklySchedule)
    ? businessHours.weeklySchedule
    : [];
  const scheduleEntry = schedule.find(
    (entry) => Number(entry.day) === weekday
  );

  if (scheduleEntry && scheduleEntry.enabled === false) {
    return { isOpen: false, reason: "Dia fechado." };
  }
  if (!scheduleEntry && closed.includes(weekday)) {
    return { isOpen: false, reason: "Dia fechado." };
  }

  const openTime =
    scheduleEntry.openTime ||
    businessHours.openTime ||
    DEFAULT_BUSINESS_HOURS.openTime;
  const closeTime =
    scheduleEntry.closeTime ||
    businessHours.closeTime ||
    DEFAULT_BUSINESS_HOURS.closeTime;

  const nowMinutes = date.getHours() * 60 + date.getMinutes();
  const openMinutes = parseTimeToMinutes(openTime);
  const closeMinutes = parseTimeToMinutes(closeTime);
  const isOpen = isWithinTimeRange(nowMinutes, openMinutes, closeMinutes);
  return {
    isOpen,
    reason: isOpen ? "" : "Fora do horário de funcionamento.",
  };
}

function isWithinPeakWindow(peakFee, date = new Date()) {
  if (!peakFee.enabled) return false;
  const days = Array.isArray(peakFee.days) ? peakFee.days : [];
  const weekday = date.getDay();
  if (days.length > 0 && !days.includes(weekday)) return false;
  const nowMinutes = date.getHours() * 60 + date.getMinutes();
  const startMinutes = parseTimeToMinutes(peakFee.startTime);
  const endMinutes = parseTimeToMinutes(peakFee.endTime);
  return isWithinTimeRange(nowMinutes, startMinutes, endMinutes);
}

/**
 * Encontra faixa de entrega pela distância em km
 */
function findDeliveryRangeForKm(distanceKm, deliveryConfig) {
  if (!deliveryConfig || !Array.isArray(deliveryConfig.ranges)) return null;
  const km = parseKmValue(distanceKm);
  if (km <= 0) return null;

  for (const r of deliveryConfig.ranges) {
    const min = parseKmValue(r.minKm);
    const max = parseKmValue(r.maxKm);
    if (km >= min && km <= max) {
      return r;
    }
  }

  // se não encontrou, usa última faixa como padrão
  return deliveryConfig.ranges[deliveryConfig.ranges.length - 1] || null;
}

function formatDecimalInput(value) {
  if (value === null || value === undefined || value === "") return "";
  const normalized = String(value).trim().replace(",", ".");
  const num = Number(normalized);
  if (Number.isNaN(num)) return "";
  return String(num).replace(".", ",");
}

function toDecimalString(value, fallback = "0") {
  const formatted = formatDecimalInput(value);
  return formatted !== "" ? formatted : fallback;
}

function readOrderDraftFromStorage() {
  try {
    if (!window.localStorage) return null;
    const raw = window.localStorage.getItem(ORDER_DRAFT_STORAGE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    return parsed && typeof parsed === "object" ? parsed : null;
  } catch (err) {
    console.warn("[NewOrderModal] draft read failed:", err);
    return null;
  }
}

function writeOrderDraftToStorage(payload) {
  try {
    if (!window.localStorage) return;
    window.localStorage.setItem(
      ORDER_DRAFT_STORAGE_KEY,
      JSON.stringify(payload)
    );
  } catch (err) {
    console.warn("[NewOrderModal] draft write failed:", err);
  }
}

function clearOrderDraftStorage() {
  try {
    if (!window.localStorage) return;
    window.localStorage.removeItem(ORDER_DRAFT_STORAGE_KEY);
  } catch (err) {
    console.warn("[NewOrderModal] draft clear failed:", err);
  }
}

function resolveOrderTypePayload(order) {
  const typeRaw =
    (order.orderType ||
      order.type ||
      order.delivery.mode ||
      (order.source === "pickup" ? "pickup" : "") ||
      "")
      .toString()
      .toLowerCase()
      .trim();

  if (["pickup", "retirada"].includes(typeRaw)) {
    return "pickup";
  }
  if (["counter", "balcao", "balcão", "local"].includes(typeRaw)) {
    return "counter";
  }
  return "delivery";
}

/**
 * Tenta usar um bridge JS -> main para calcular a distância (em km)
 * A ideia é você implementar um desses caminhos no main:
 *  - window.deliveryApi.calculateDistanceKm(origin, destination)
 * ? - ipcRenderer.invoke("delivery:calculateDistanceKm", { origin, destination })
 */
async function calculateDistanceKmUsingBridge(origin, destination) {
  try {
    // 1) API exposta direto no preload
    if (window.deliveryApi.calculateDistanceKm) {
      const result = await window.deliveryApi.calculateDistanceKm(
        origin,
        destination
      );
      if (typeof result === "number") return result;
      if (result && typeof result.distanceKm === "number")
        return result.distanceKm;
      if (result && typeof result.km === "number") return result.km;
    }

    // 2) IPC padrão
    if (window.electron.ipcRenderer.invoke) {
      const result = await window.electron.ipcRenderer.invoke(
        "delivery:calculateDistanceKm",
        { origin, destination }
      );
      if (typeof result === "number") return result;
      if (result && typeof result.distanceKm === "number")
        return result.distanceKm;
      if (result && typeof result.km === "number") return result.km;
    }
  } catch (err) {
    console.error("[NewOrderModal] calculateDistanceKmUsingBridge error:", err);
  }
  return null;
}

/**
 * Normaliza coleção de produtos vinda do DataEngine / catálogo
 */
function findById(id, collection) {
  return collection.find((p) => p && p.id != null && String(p.id) === String(id));
}

export default function NewOrderModal({
  isOpen,
  onClose,
  onConfirm,
  formatCurrency,
  initialCatalog,
  initialOrder,
}) {
  // -----------------------------
  // Estado vindo do DB
  // -----------------------------
  const [customers, setCustomers] = useState([]);
  const [pizzaCatalog, setPizzaCatalog] = useState([]);
  const [drinkCatalog, setDrinkCatalog] = useState([]);
  const [extraCatalog, setExtraCatalog] = useState([]);
  const [deliveryConfig, setDeliveryConfig] = useState(DEFAULT_DELIVERY_CONFIG);
  const [businessHours, setBusinessHours] = useState(
    DEFAULT_BUSINESS_HOURS
  );
  const [isLoading, setIsLoading] = useState(false);
  const [loadError, setLoadError] = useState("");
  const [submitError, setSubmitError] = useState("");

  const customerSearchRef = useRef(null);
  const counterLabelRef = useRef(null);
  const pizzaQuantityRef = useRef(null);
  const deliveryNeighborhoodRef = useRef(null);
  const distanceSectionRef = useRef(null);

  // -----------------------------
  // Cliente
  // -----------------------------
  const [customerMode, setCustomerMode] = useState("registered"); // registered | counter
  const [customerSearch, setCustomerSearch] = useState("");
  const [selectedCustomerId, setSelectedCustomerId] = useState(null);
  const [showCustomerSearch, setShowCustomerSearch] = useState(true);
  const [counterLabel, setCounterLabel] = useState("Balcão");
  const [selectedCustomerAddressId, setSelectedCustomerAddressId] =
    useState("primary");
  const [showCustomerEditModal, setShowCustomerEditModal] = useState(false);
  const [showAltAddressModal, setShowAltAddressModal] = useState(false);
  const [showCustomerModal, setShowCustomerModal] = useState(false);
  const [showPizzaModal, setShowPizzaModal] = useState(false);
  const [showDrinkModal, setShowDrinkModal] = useState(false);
  const [altAddressDraft, setAltAddressDraft] = useState(() =>
    createEmptyAltAddress()
  );
  const [altAddressError, setAltAddressError] = useState("");
  const [isSyncingCustomerAddress, setIsSyncingCustomerAddress] =
    useState(false);
  const lastAddressSyncRef = useRef("");
  const lastDistanceCalcRef = useRef("");

  // -----------------------------
  // Pizza atual (editor)
  // -----------------------------
  const [size, setSize] = useState("grande");
  const [quantity, setQuantity] = useState(1);
  const [flavorSearch, setFlavorSearch] = useState("");
  const [flavor1, setFlavor1] = useState("");
  const [flavor2, setFlavor2] = useState("");
  const [flavor3, setFlavor3] = useState("");
  const [twoFlavorsEnabled, setTwoFlavorsEnabled] = useState(false);
  const [threeFlavorsEnabled, setThreeFlavorsEnabled] = useState(false);
  const [selectedExtras, setSelectedExtras] = useState([]); // array de IDs de extras
  const [extrasOpen, setExtrasOpen] = useState(false); // toggle para exibir/ocultar adicionais

  // slot ativo para seleção por cards
  const [activeFlavorSlot, setActiveFlavorSlot] = useState("flavor1");

  // -----------------------------
  // Seleção de Borda (do catálogo)
  // -----------------------------
  const pizzaCrusts = useMemo(() => {
    const fallbackCrusts = [
      { id: "tradicional", name: "Tradicional", price: 0 },
      { id: "catupiry", name: "Catupiry", price: 2.5 },
      { id: "cheddar", name: "Cheddar", price: 3.0 },
    ];

    if (!extraCatalog.length) {
      return fallbackCrusts;
    }

    const crusts = extraCatalog
      .filter((extra) => {
        if (!extra || typeof extra !== "object") return false;
        const category = (extra.categoria || "").toLowerCase();
        const name = (extra.name || "").toLowerCase();
        return category.includes("borda") || name.includes("borda");
      })
      .map((extra) => {
        const price =
          size === "broto"
            ? extra?.prices?.broto || 0
            : extra?.prices?.grande || extra?.prices?.broto || 0;

        return {
          id: String(extra.id),
          name: extra.name || "Borda",
          price,
        };
      })
      .filter(Boolean);

    const baseCrust = { id: "tradicional", name: "Tradicional", price: 0 };
    const merged = [baseCrust].concat(
      crusts.filter(
        (item) =>
          item &&
          item.id !== baseCrust.id &&
          item.name.toLowerCase() !== baseCrust.name.toLowerCase()
      )
    );

    return merged.length ? merged : fallbackCrusts;
  }, [extraCatalog, size]);

  const [selectedCrust, setSelectedCrust] = useState("tradicional");

  // Atualizar selectedCrust quando pizzaCrusts mudar
  useEffect(() => {
    if (
      pizzaCrusts.length > 0 &&
      !pizzaCrusts.find((c) => c && c.id === selectedCrust)
    ) {
      setSelectedCrust(pizzaCrusts[0].id);
    }
  }, [pizzaCrusts, selectedCrust]);

  // -----------------------------
  // Ingredientes Extras (extraídos do catálogo de pizzas)
  // -----------------------------
  const pizzaIngredients = useMemo(() => {
    if (!pizzaCatalog.length) return [];
    
    const ingredientMap = new Map();
    
    pizzaCatalog.forEach(pizza => {
      // Extrair ingredientes da descrição ou campo de ingredientes
      const descriptionMatch = (pizza.description || '').match(/queijo|molho|calabresa|presunto|frango|catupiry|bacon|atum|milho|ervilha|palmito|azeitona|cebola|tomate|pimentão|oregano/gi) || [];
      const ingredients = [
        ...descriptionMatch,
        // Se tiver campo de ingredientes específico
        ...(pizza.ingredients || [])
      ].filter(Boolean);
      
      ingredients.forEach(ingredient => {
        const normalized = ingredient.toLowerCase().trim();
        if (!ingredientMap.has(normalized)) {
          ingredientMap.set(normalized, {
            name: ingredient.charAt(0).toUpperCase() + ingredient.slice(1),
            basePrice: size === "broto" ? 2.50 : 4.00, // Preço base por ingrediente
            usageCount: 0
          });
        }
        ingredientMap.get(normalized).usageCount++;
      });
    });
    
    // Ordenar por frequência de uso e nome
    return Array.from(ingredientMap.values())
      .sort((a, b) => {
        if (b.usageCount !== a.usageCount) {
          return b.usageCount - a.usageCount;
        }
        return a.name.localeCompare(b.name);
      })
      .slice(0, 20); // Limitar aos 20 mais usados
  }, [pizzaCatalog]);

  // -----------------------------
  // Bebida atual (editor)
  // -----------------------------
  const [drinkSearch, setDrinkSearch] = useState("");
  const [selectedDrinkId, setSelectedDrinkId] = useState("");
  const [drinkQuantity, setDrinkQuantity] = useState(1);

  // -----------------------------
  // Itens (múltiplas linhas: pizzas + bebidas)
  // -----------------------------
  const [orderItems, setOrderItems] = useState([]);
  const [editingItem, setEditingItem] = useState(null);

  useEffect(() => {
    if (!showPizzaModal || editingItem) return;
    const hasTraditional = pizzaCrusts.find(
      (c) => c && c.id === "tradicional"
    );
    if (hasTraditional) {
      setSelectedCrust("tradicional");
    }
  }, [showPizzaModal, editingItem, pizzaCrusts]);

  // -----------------------------
  // Dados adicionais do pedido
  // -----------------------------
  const [status] = useState("open");
  const [orderType, setOrderType] = useState("delivery");
  const [paymentMethod, setPaymentMethod] = useState("");

  const [deliveryDistanceKm, setDeliveryDistanceKm] = useState(""); // distância em km (auto)
  const [deliveryNeighborhood, setDeliveryNeighborhood] = useState(""); // rótulo da faixa (label exibida)
  const [deliveryAddressNeighborhood, setDeliveryAddressNeighborhood] =
    useState("");
  const [deliveryFee, setDeliveryFee] = useState("0"); // valor em R$, calculado pela faixa
  const [selectedDeliveryRangeId, setSelectedDeliveryRangeId] = useState(""); // faixa de entrega escolhida

  const [discountType, setDiscountType] = useState("none"); // none | value | percent
  const [discountValue, setDiscountValue] = useState("0");
  const [orderNotes, setOrderNotes] = useState("");
  const [kitchenNotes, setKitchenNotes] = useState("");

  const [cashGiven, setCashGiven] = useState("");

  // -----------------------------
  // Modular Modal States
  // -----------------------------
  const [activeSubModal, setActiveSubModal] = useState(null);
  const [showOrderItemsModal, setShowOrderItemsModal] = useState(false);
  const [showCustomerInfoModal, setShowCustomerInfoModal] = useState(false);
  const [showDeliveryAddressModal, setShowDeliveryAddressModal] = useState(false);
  const [showOrderStatusModal, setShowOrderStatusModal] = useState(false);
  const [showOrderSummaryModal, setShowOrderSummaryModal] = useState(false);
  const [showPaymentModal, setShowPaymentModal] = useState(false);
  const [showOrderOptionsModal, setShowOrderOptionsModal] = useState(false);
  const [showCustomerHistoryModal, setShowCustomerHistoryModal] = useState(false);
  const [allOrders, setAllOrders] = useState([]);
  const [lastAutoSave, setLastAutoSave] = useState(null);
  
  // Store address (could come from settings in the future)
  const [storeAddress] = useState({
    street: "Rua das Pizzas",
    number: "123",
    neighborhood: "Centro",
    city: "São Paulo",
    state: "SP",
    cep: "01234-567"
  });

  // estados auxiliares do cálculo automático
  const [isCalculatingDistance, setIsCalculatingDistance] = useState(false);
  const [distanceError, setDistanceError] = useState("");
  const initialOrderRef = useRef(null);
  const hydratePendingRef = useRef(false);
  const draftRestoredRef = useRef(false);

  const hydrateInitialOrder = useCallback(
    (order) => {
      if (!order) return;

      const baseTimestamp = Date.now();
 const normalizedItems = (Array.isArray(order.items) ? order.items : []).map(
        (item, idx) => ({
          ...item,
          lineId:
            item.lineId ||
            item.id ||
            `line-${baseTimestamp}-${idx}-${Math.floor(Math.random() * 1000)}`,
        })
      );

      setOrderItems(normalizedItems);

      const snapshot = order.customerSnapshot || {};
      const snapshotName =
        snapshot.name ||
        order.customerName ||
        order.customer.name ||
        order.customer.customerName ||
        "Cliente";
      const preferCounter =
        (order.customerMode || "")
          .toString()
          .toLowerCase()
          .trim() === "counter";

      const customerIdCandidate =
        order.customerId ||
        snapshot.id ||
        order.customer.id ||
        order.customer.customerId ||
        null;
      let matchingCustomer =
        customerIdCandidate != null
          ? customers.find(
              (c) => String(c.id) === String(customerIdCandidate)
            )
          : null;

      if (!matchingCustomer) {
        const candidatePhone = digitsOnly(
          snapshot.phone ||
            order.customerPhone ||
            order.customer.phone ||
            ""
        );
        if (candidatePhone) {
          matchingCustomer =
            customers.find(
              (c) =>
                digitsOnly(c.phone || c.telefone || "") === candidatePhone
            ) || matchingCustomer;
        }
      }

      if (!matchingCustomer) {
        const candidateCpf = digitsOnly(
          snapshot.cpf ||
            order.customerCpf ||
            order.customer.cpf ||
            order.customer.document ||
            ""
        );
        if (candidateCpf) {
          matchingCustomer =
            customers.find(
              (c) =>
                digitsOnly(c.cpf || c.document || c.cpf_cnpj || "") ===
                candidateCpf
            ) || matchingCustomer;
        }
      }

      if (!preferCounter && matchingCustomer) {
        setCustomerMode("registered");
        setSelectedCustomerId(matchingCustomer.id);
        const addressIdCandidate =
          order.customerAddressId ||
          order.customerAddress.id ||
          order.customer.addressId ||
          null;
        if (addressIdCandidate && matchingCustomer && Array.isArray(matchingCustomer.addresses)) {
          const exists = matchingCustomer.addresses.some(
            (addr) => String(addr.id) === String(addressIdCandidate)
          );
          setSelectedCustomerAddressId(
 exists ? addressIdCandidate : "primary"
          );
        } else {
          setSelectedCustomerAddressId("primary");
        }
        setShowCustomerSearch(!!customers.length);
        setCounterLabel("Balcão");
      } else {
        setCustomerMode("counter");
        setSelectedCustomerId(null);
        setSelectedCustomerAddressId("primary");
        setShowCustomerSearch(false);
        const counterLabelValue =
          (order.counterLabel || snapshotName || "").trim() || "Cliente";
        setCounterLabel(counterLabelValue);
      }

      setCustomerSearch("");

      setOrderType(resolveOrderTypePayload(order));

      const paymentMethodRaw = (
        order.payment.method || order.paymentMethod || ""
      ).toString();
      setPaymentMethod(paymentMethodRaw.toLowerCase());

      setOrderNotes(
        order.orderNotes ||
          order.notes ||
          order.observacao ||
          order.obs ||
          ""
      );
      setKitchenNotes(
        order.kitchenNotes || order.kitchen || order.observacoes || ""
      );

      const deliveryFeeValue =
        order.delivery.fee 
        order.totals.deliveryFee 
        order.deliveryFee 
        0;
      setDeliveryFee(toDecimalString(deliveryFeeValue));

      setDeliveryNeighborhood(
        order.delivery.neighborhood ||
          order.deliveryNeighborhood ||
          order.delivery.bairro ||
          ""
      );

      const addressNeighborhood =
        order.customerAddress.neighborhood ||
        order.customerAddress.bairro ||
        order.customer.address.neighborhood ||
        order.customer.address.bairro ||
        order.delivery.neighborhood ||
        order.delivery.bairro ||
        "";
      setDeliveryAddressNeighborhood(addressNeighborhood);

      const distanceValue =
        order.deliveryDistanceKm ||
        order.delivery.distanceKm ||
        order.delivery.distance ||
        "";
      setDeliveryDistanceKm(toDecimalString(distanceValue, ""));

      const discountSource = order.discount;
      const totalsDiscount =
        typeof order.totals.discount === "number"
          ? order.totals.discount
          : null;
      const discountValueRaw =
        typeof discountSource === "object"
          ? discountSource.value ?? discountSource.amount ?? null
          : typeof discountSource === "number"
          ? discountSource
          : order.discountValue ??
            order.discountAmount ??
            totalsDiscount ??
            null;
      const numericDiscount =
        discountValueRaw !== null && discountValueRaw !== undefined
          ? Number(String(discountValueRaw).replace(",", "."))
          : 0;

      const formattedDiscountValue = toDecimalString(discountValueRaw);
      if (numericDiscount > 0) {
        const discountTypeValue =
          (typeof discountSource === "object" &&
            discountSource.type === "percent") ||
          order.discountType === "percent"
            ? "percent"
            : "value";
        setDiscountType(discountTypeValue);
        setDiscountValue(formattedDiscountValue);
      } else {
        setDiscountType("none");
        setDiscountValue("0");
      }

      const cashGivenValue =
        order.payment.cashGiven ??
        order.cash.cashGiven ??
        order.cashGiven ??
        0;
      setCashGiven(toDecimalString(cashGivenValue));
    },
    [customers]
  );

  useEffect(() => {
    if (!isOpen || !initialOrder) {
      initialOrderRef.current = null;
      hydratePendingRef.current = false;
      return;
    }

    if (initialOrderRef.current !== initialOrder) {
      initialOrderRef.current = initialOrder;
      hydratePendingRef.current = true;
    }
  }, [initialOrder, isOpen]);

  useEffect(() => {
    if (
      !isOpen ||
      !initialOrder ||
      isLoading ||
      !hydratePendingRef.current
    ) {
      return;
    }

    hydrateInitialOrder(initialOrder);
    hydratePendingRef.current = false;
  }, [initialOrder, isLoading, isOpen, hydrateInitialOrder]);
  // -----------------------------
  // Load do banco
  // -----------------------------
  useEffect(() => {
    if (!isOpen) return;

    let cancel = false;
    const isEditing = Boolean(initialOrder);

    async function load() {
      setIsLoading(true);
      setLoadError("");

      try {
        let productsDb = initialCatalog || null;

        if (!productsDb) {
          if (!window.dataEngine) {
            throw new Error("API local window.dataEngine não encontrada.");
          }

          const [customersDb, products, settingsDb, ordersDb] = await Promise.all([
            window.dataEngine.get("customers"),
            window.dataEngine.get("products"),
            window.dataEngine.get("settings"),
            window.dataEngine.get("orders"),
          ]);

          if (cancel) return;

          const customersArr = customersDb && Array.isArray(customersDb.items)
             ? customersDb.items
            : customersDb && Array.isArray(customersDb)
             ? customersDb
            : [];

          const ordersArr = ordersDb && Array.isArray(ordersDb.items)
             ? ordersDb.items
            : ordersDb && Array.isArray(ordersDb)
             ? ordersDb
            : [];

          const { pizzas, drinks, extras } =
            normalizeProductsCollections(products);

          const dCfg = normalizeDeliveryConfigFromSettings(settingsDb);
          const bHours = normalizeBusinessHoursFromSettings(settingsDb);

          setCustomers(customersArr);
          setAllOrders(ordersArr);
          setPizzaCatalog(pizzas);
          setDrinkCatalog(drinks);
          setExtraCatalog(extras);
          setDeliveryConfig(dCfg);
          setBusinessHours(bHours);

          if (!isEditing) {
 setCustomerMode(customersArr.length ? "registered" : "counter");
            setCustomerSearch("");
            setSelectedCustomerId(null);
            setSelectedCustomerAddressId("primary");
            setShowCustomerSearch(true);
            setCounterLabel("Balcão");

            setFlavorSearch("");
            setTwoFlavorsEnabled(false);
            setThreeFlavorsEnabled(false);
            setSize("grande");
            setQuantity(1);
            setFlavor1(pizzas[0].id || "");
            setFlavor2("");
            setFlavor3("");
            setSelectedExtras([]);
            setExtrasOpen(false);
            setActiveFlavorSlot("flavor1");

            setOrderItems([]);

            setDrinkSearch("");
            setSelectedDrinkId(drinks[0].id || "");
            setDrinkQuantity(1);

            setOrderType("delivery");
            setPaymentMethod("");
            setDeliveryDistanceKm("");
            setDeliveryNeighborhood("");
            setDeliveryAddressNeighborhood("");
            setDeliveryFee("0");
            setDiscountType("none");
            setDiscountValue("0");
            setOrderNotes("");
            setKitchenNotes("");
            setCashGiven("");

            setDistanceError("");
            setIsCalculatingDistance(false);
          }

          return;
        }

        // caminho com initialCatalog (sem DataEngine completo)
        const { pizzas, drinks, extras } =
          normalizeProductsCollections(productsDb);

        setCustomers([]);
        setPizzaCatalog(pizzas);
        setDrinkCatalog(drinks);
        setExtraCatalog(extras);
        setDeliveryConfig(DEFAULT_DELIVERY_CONFIG);
        setBusinessHours(DEFAULT_BUSINESS_HOURS);

        if (!isEditing) {
          setCustomerMode("counter");
          setCustomerSearch("");
          setSelectedCustomerId(null);
          setSelectedCustomerAddressId("primary");
          setShowCustomerSearch(false);
          setCounterLabel("Balcão");

          setFlavorSearch("");
          setTwoFlavorsEnabled(false);
          setThreeFlavorsEnabled(false);
          setSize("grande");
          setQuantity(1);
          setFlavor1(pizzas[0].id || "");
          setFlavor2("");
          setFlavor3("");
          setSelectedExtras([]);
          setExtrasOpen(false);
          setActiveFlavorSlot("flavor1");

          setOrderItems([]);

          setDrinkSearch("");
          setSelectedDrinkId(drinks[0].id || "");
          setDrinkQuantity(1);

          setOrderType("delivery");
          setPaymentMethod("");
          setDeliveryDistanceKm("");
          setDeliveryNeighborhood("");
          setDeliveryAddressNeighborhood("");
          setDeliveryFee("0");
          setDiscountType("none");
          setDiscountValue("0");
          setOrderNotes("");
          setKitchenNotes("");
          setCashGiven("");

          setDistanceError("");
          setIsCalculatingDistance(false);
        }
      } catch (err) {
        console.error("[NewOrderModal] load error:", err);
        if (!cancel) setLoadError(err.message || "Erro ao carregar dados.");
      } finally {
        if (!cancel) setIsLoading(false);
      }
    }

    load();
    return () => {
      cancel = true;
    };
  }, [isOpen, initialCatalog, initialOrder]);

  const openCustomerModal = () => setShowCustomerInfoModal(true);
  const openAddressModal = () => setShowDeliveryAddressModal(true);
  const openOrderItemsModal = () => setShowOrderItemsModal(true);
  const openOrderStatusModal = () => setShowOrderStatusModal(true);
  const openOrderOptionsModal = () => setShowOrderOptionsModal(true);
  const openPaymentModal = () => setShowPaymentModal(true);

  // -----------------------------
  // Cliente selecionado (memo)
  // -----------------------------
  const filteredCustomers = useMemo(() => {
    const term = customerSearch.trim().toLowerCase();
    if (!term) return customers;

    const digits = digitsOnly(term);
    const hasDigits = digits.length > 0;

    return customers.filter((c) => {
      const name = (c.name || c.nome || "").toLowerCase();
      const phone = (c.phone || c.phoneRaw || c.telefone || "")
        .toString()
        .toLowerCase();
      const cpf = (c.cpf || c.document || c.cpf_cnpj || "")
        .toString()
        .toLowerCase();
      const phoneDigits = digitsOnly(
        c.phone || c.phoneRaw || c.telefone || ""
      );
      const cpfDigits = digitsOnly(c.cpf || c.document || c.cpf_cnpj || "");

      const matchesText =
        name.includes(term) || phone.includes(term) || cpf.includes(term);
      const matchesDigits =
        hasDigits &&
        (phoneDigits.includes(digits) || cpfDigits.includes(digits));

      return matchesText || matchesDigits;
    });
  }, [customers, customerSearch]);

  const selectedCustomer = useMemo(
    () => customers.find((c) => c && c.id === selectedCustomerId),
    [customers, selectedCustomerId]
  );


  useEffect(() => {
    if (!selectedCustomerId) {
      if (selectedCustomerAddressId !== "primary") {
        setSelectedCustomerAddressId("primary");
      }
      return;
    }

    if (!selectedCustomerAddressId) {
      setSelectedCustomerAddressId("primary");
      return;
    }

    if (selectedCustomerAddressId === "primary") return;

    const customer = customers.find(
      (c) => String(c.id) === String(selectedCustomerId)
    );
    if (!customer || !customer.addresses) {
      setSelectedCustomerAddressId("primary");
      return;
    }
    const addresses = Array.isArray(customer.addresses)
      ? customer.addresses
      : [];
    const exists = addresses.some(
      (addr) => String(addr.id) === String(selectedCustomerAddressId)
    );

    if (!exists) {
      setSelectedCustomerAddressId("primary");
    }
  }, [selectedCustomerId, selectedCustomerAddressId, customers]);

  const customerAltAddresses = useMemo(() => {
    if (!selectedCustomer || !selectedCustomer.addresses) return [];
    return Array.isArray(selectedCustomer.addresses)
      ? selectedCustomer.addresses
      : [];
  }, [selectedCustomer]);

  const activeCustomerAddress = useMemo(() => {
    if (!selectedCustomer) return null;
    if (selectedCustomerAddressId === "primary") {
      return selectedCustomer.address || null;
    }
    return (
      customerAltAddresses.find(
        (addr) => String(addr.id) === String(selectedCustomerAddressId)
      ) ||
      selectedCustomer.address ||
      null
    );
  }, [selectedCustomer, customerAltAddresses, selectedCustomerAddressId]);

  const activeCustomerAddressLabel = useMemo(() => {
    if (!selectedCustomer) return "";
    if (selectedCustomerAddressId === "primary") return "Endereço principal";
    const match = customerAltAddresses.find(
      (addr) => String(addr.id) === String(selectedCustomerAddressId)
    );
    const label = match.label || match.apelido || "";
 return label ? `Alternativo: ${label}` : "Endereço alternativo";
  }, [selectedCustomer, customerAltAddresses, selectedCustomerAddressId]);

  useEffect(() => {
    if (customerMode !== "registered") return;
    const addr = activeCustomerAddress || {};
    const neighborhood = addr.neighborhood || addr.bairro || "";
    setDeliveryAddressNeighborhood(neighborhood);
  }, [
    selectedCustomerId,
    selectedCustomerAddressId,
    customerMode,
    activeCustomerAddress,
  ]);

  const recentCustomers = useMemo(() => {
    if (!customers.length) return [];
    const mapped = customers
      .map((c) => {
        const lastOrderAt =
          (c.meta && c.meta.lastOrderAt) || c.lastOrderAt || c.updatedAt || c.createdAt;
        const ts = Date.parse(lastOrderAt || "");
 return { customer: c, ts: Number.isNaN(ts) ? 0 : ts };
      })
      .filter((entry) => entry.ts > 0)
      .sort((a, b) => b.ts - a.ts)
      .slice(0, 5);
    return mapped.map((entry) => entry.customer);
  }, [customers]);

  const refreshCustomers = useCallback(async () => {
    if (!window.dataEngine.get) return [];
    try {
      const customersDb = await window.dataEngine.get("customers");
      const customersArr = customersDb && Array.isArray(customersDb.items)
         ? customersDb.items
        : customersDb && Array.isArray(customersDb)
         ? customersDb
        : [];
      setCustomers(customersArr);
      return customersArr;
    } catch (err) {
      console.error("[OrderFormModal] Erro ao recarregar clientes:", err);
      return [];
    }
  }, []);

  const updateCustomerRecord = useCallback(async (id, changes) => {
    if (!window.dataEngine.updateItem) return null;
    try {
      const updated = await window.dataEngine.updateItem(
        "customers",
        id,
        changes
      );
      setCustomers((prev) =>
 prev.map((c) => (String(c.id) === String(id) ? updated : c))
      );
      return updated;
    } catch (err) {
      console.error("[OrderFormModal] Erro ao atualizar cliente:", err);
      return null;
    }
  }, []);

  useEffect(() => {
    if (!showAltAddressModal) return;
    setAltAddressDraft(createEmptyAltAddress());
    setAltAddressError("");
  }, [showAltAddressModal]);

  const handleAltAddressFieldChange = (field, value) => {
    if (altAddressError) {
      setAltAddressError("");
    }
    setAltAddressDraft((prev) => ({
      ...prev,
      [field]: value,
    }));
  };

  const handleAltAddressCepLookup = async () => {
    const cepDigits = digitsOnly(altAddressDraft.cep);
    if (cepDigits.length !== 8) {
      setAltAddressError("CEP deve ter 8 dígitos.");
      return;
    }
    try {
      setAltAddressError("");
      const data = await lookupCep(cepDigits);
      setAltAddressDraft((prev) => ({
        ...prev,
        cep: data.cep,
        street: prev.street || data.street,
        neighborhood: prev.neighborhood || data.neighborhood,
        city: data.city,
        state: data.state,
      }));
    } catch (err) {
      setAltAddressError(err.message || "Não foi possível buscar o CEP.");
    }
  };

  const handleUseAddress = (addressId) => {
    setSelectedCustomerAddressId(addressId);
    setShowAltAddressModal(false);

    const addr =
      addressId === "primary"
         ? selectedCustomer.address
        : customerAltAddresses.find(
            (item) => String(item.id) === String(addressId)
          );

    if (addr.neighborhood || addr.bairro) {
      setDeliveryAddressNeighborhood(
        addr.neighborhood || addr.bairro || ""
      );
    }
  };

  const handleSaveAltAddress = async () => {
    if (!selectedCustomer) return;
    setAltAddressError("");

    const cepDigits = digitsOnly(altAddressDraft.cep);
    let draft = {
      ...altAddressDraft,
      cep: cepDigits,
      street: altAddressDraft.street.trim(),
      neighborhood: altAddressDraft.neighborhood.trim(),
      city: altAddressDraft.city.trim(),
      state: altAddressDraft.state.trim(),
      number: altAddressDraft.number.trim(),
      complement: altAddressDraft.complement.trim(),
      reference: altAddressDraft.reference.trim(),
      label: altAddressDraft.label.trim(),
    };

    if (cepDigits.length === 8 && (!draft.city || !draft.state)) {
      try {
        const data = await lookupCep(cepDigits);
        draft = {
          ...draft,
          street: draft.street || data.street,
          neighborhood: draft.neighborhood || data.neighborhood,
          city: draft.city || data.city,
          state: draft.state || data.state,
        };
      } catch (err) {
        setAltAddressError(err.message || "Não foi possível buscar o CEP.");
        return;
      }
    }

    if (
      !cepDigits &&
      draft.street &&
      draft.city &&
      draft.state
    ) {
      try {
        const data = await lookupCepByAddress({
          street: draft.street,
          city: draft.city,
          state: draft.state,
        });
        draft = {
          ...draft,
          cep: data.cep || draft.cep,
          neighborhood: draft.neighborhood || data.neighborhood,
        };
      } catch (err) {
        setAltAddressError(
          err.message || "Não foi possível identificar o CEP."
        );
        return;
      }
    }

    const missing = getMissingAddressFields(
      draft,
      draft.neighborhood || ""
    );
    if (missing.length > 0) {
      setAltAddressError(
        `Endereço incompleto. Faltam: ${missing.join(", ")}.`
      );
      return;
    }

    const newId =
      draft.id ||
      `addr-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
    const nextAddress = {
      ...draft,
      id: newId,
      label:
        draft.label ||
        `Endereço ${customerAltAddresses.length + 1}`,
    };

    const updatedAddresses = [
      ...customerAltAddresses.filter(
        (item) => String(item.id) !== String(newId)
      ),
      nextAddress,
    ];

    const updatedCustomer = await updateCustomerRecord(
      selectedCustomer.id,
      {
        addresses: updatedAddresses,
      }
    );

    if (updatedCustomer) {
      setSelectedCustomerAddressId(newId);
      setShowAltAddressModal(false);
      setDeliveryAddressNeighborhood(
        nextAddress.neighborhood || ""
      );
    }
  };

  const handleNewAddress = async (newAddressData) => {
    if (!selectedCustomer) {
      emitToast({
        type: "error",
        message: "Selecione um cliente primeiro.",
      });
      return;
    }

    try {
      const newId = `addr_${Date.now()}_${Math.random().toString(16).slice(2)}`;
      const nextAddress = {
        ...newAddressData,
        id: newId,
        label: newAddressData.label || `Endereço ${customerAltAddresses.length + 1}`,
      };

      const updatedAddresses = [...customerAltAddresses, nextAddress];

      const updatedCustomer = await updateCustomerRecord(
        selectedCustomer.id,
        {
          addresses: updatedAddresses,
        }
      );

      if (updatedCustomer) {
        setSelectedCustomerAddressId(newId);
        setDeliveryAddressNeighborhood(nextAddress.neighborhood || "");
        emitToast({
          type: "success",
          message: "Novo endereço cadastrado com sucesso!",
        });
      }
    } catch (error) {
      console.error("Erro ao salvar novo endereço:", error);
      emitToast({
        type: "error",
        message: "Erro ao cadastrar novo endereço. Tente novamente.",
      });
    }
  };

  const deliveryNeighborhoodValue = useMemo(() => {
    if (deliveryAddressNeighborhood) return deliveryAddressNeighborhood.trim();
    const addr = activeCustomerAddress || {};
    return addr.neighborhood || addr.bairro || "";
  }, [deliveryAddressNeighborhood, activeCustomerAddress]);

  const customerAddressLines = useMemo(() => {
    if (!activeCustomerAddress) {
      return { line1: "", line2: "" };
    }
    const addr = normalizeAddressParts(
      activeCustomerAddress,
      deliveryNeighborhoodValue
    );
    let line1 = "";
    if (addr.street) {
      line1 = addr.street;
      if (addr.number) line1 += `, ${addr.number}`;
    }

    const neighborhood = addr.neighborhood;
    let line2 = "";
    if (neighborhood) line2 = neighborhood;
 if (addr.city) line2 += (line2 ? " - " : "") + addr.city;
 if (addr.state) line2 += (line2 ? " / " : "") + addr.state;

    return { line1, line2 };
  }, [activeCustomerAddress, deliveryNeighborhoodValue]);

  const missingAddressFields = useMemo(() => {
    if (!selectedCustomer || customerMode !== "registered") return [];
    return getMissingAddressFields(
      activeCustomerAddress,
      deliveryNeighborhoodValue
    );
  }, [selectedCustomer, customerMode, deliveryNeighborhoodValue, activeCustomerAddress]);

  const isDeliveryAddressComplete = missingAddressFields.length === 0;

  const blockedNeighborhoodMatch = useMemo(() => {
    if (!deliveryNeighborhoodValue) return null;
    return findBlockedNeighborhood(
      deliveryNeighborhoodValue,
      deliveryConfig.blockedNeighborhoods
    );
  }, [deliveryNeighborhoodValue, deliveryConfig.blockedNeighborhoods]);

  const deliveryTypeBlockedReason = useMemo(() => {
    if (customerMode !== "registered") {
      return "Disponível apenas para clientes cadastrados.";
    }
    if (!selectedCustomer) {
      return "Selecione um cliente cadastrado.";
    }
    if (!isDeliveryAddressComplete) {
      return `Endereço incompleto: ${missingAddressFields.join(", ")}.`;
    }
    if (blockedNeighborhoodMatch) {
      return `Bairro bloqueado: ${blockedNeighborhoodMatch}.`;
    }
    return "";
  }, [
    customerMode,
    selectedCustomer,
    isDeliveryAddressComplete,
    missingAddressFields,
    blockedNeighborhoodMatch,
  ]);

  const businessHoursStatus = useMemo(
    () => getBusinessHoursStatus(businessHours),
    [businessHours]
  );

  const isEditing = Boolean(initialOrder);

  const buildDraftSnapshot = useCallback(
    () => ({
      customerMode,
      selectedCustomerId,
      selectedCustomerAddressId,
      counterLabel,
      orderItems,
      orderType,
      paymentMethod,
      deliveryDistanceKm,
      deliveryNeighborhood,
      deliveryAddressNeighborhood,
      deliveryFee,
      selectedDeliveryRangeId,
      discountType,
      discountValue,
      orderNotes,
      kitchenNotes,
      cashGiven,
    }),
    [
      customerMode,
      selectedCustomerId,
      selectedCustomerAddressId,
      counterLabel,
      orderItems,
      orderType,
      paymentMethod,
      deliveryDistanceKm,
      deliveryNeighborhood,
      deliveryAddressNeighborhood,
      deliveryFee,
      selectedDeliveryRangeId,
      discountType,
      discountValue,
      orderNotes,
      kitchenNotes,
      cashGiven,
    ]
  );

  const applyDraftSnapshot = useCallback(
    (snapshot) => {
      if (!snapshot || typeof snapshot !== "object") return;

      const nextCustomerMode =
        snapshot.customerMode === "counter" ? "counter" : "registered";
      setCustomerMode(nextCustomerMode);
      setCounterLabel(snapshot.counterLabel || "Balcão");

      const customerExists = customers.some(
        (c) => String(c.id) === String(snapshot.selectedCustomerId)
      );
      const nextCustomerId = customerExists
        ? snapshot.selectedCustomerId
        : null;
      setSelectedCustomerId(nextCustomerId);
      setShowCustomerSearch(!customerExists);
      setCustomerSearch("");

      const addressIdCandidate =
        snapshot.selectedCustomerAddressId ||
        snapshot.customerAddressId ||
        "primary";
      if (!customerExists || !nextCustomerId) {
        setSelectedCustomerAddressId("primary");
      } else if (addressIdCandidate === "primary") {
        setSelectedCustomerAddressId("primary");
      } else {
        const matchedCustomer = customers.find(
          (c) => String(c.id) === String(nextCustomerId)
        );
        if (!matchedCustomer || !matchedCustomer.addresses) {
          setSelectedCustomerAddressId("primary");
          return;
        }
        const addresses = Array.isArray(matchedCustomer.addresses)
          ? matchedCustomer.addresses
          : [];
        const exists = addresses.some(
          (addr) => String(addr.id) === String(addressIdCandidate)
        );
        setSelectedCustomerAddressId(exists ? addressIdCandidate : "primary");
      }

      setOrderItems(
        Array.isArray(snapshot.orderItems) ? snapshot.orderItems : []
      );
      setOrderType(snapshot.orderType || "delivery");
      setPaymentMethod(snapshot.paymentMethod || "");
      setDeliveryDistanceKm(snapshot.deliveryDistanceKm || "");
      setDeliveryNeighborhood(snapshot.deliveryNeighborhood || "");
      setDeliveryAddressNeighborhood(
        snapshot.deliveryAddressNeighborhood || ""
      );
      setDeliveryFee(snapshot.deliveryFee || "0");
      setSelectedDeliveryRangeId(snapshot.selectedDeliveryRangeId || "");
      setDiscountType(snapshot.discountType || "none");
      setDiscountValue(snapshot.discountValue || "0");
      setOrderNotes(snapshot.orderNotes || "");
      setKitchenNotes(snapshot.kitchenNotes || "");
      setCashGiven(snapshot.cashGiven || "");
    },
    [customers]
  );

  const handleClose = useCallback(() => {
    if (!isEditing) {
      const snapshot = buildDraftSnapshot();
      const hasData =
        (snapshot.orderItems && snapshot.orderItems.length > 0) ||
        snapshot.orderNotes ||
        snapshot.kitchenNotes ||
        snapshot.deliveryDistanceKm ||
        snapshot.discountValue !== "0" ||
        snapshot.cashGiven ||
        snapshot.selectedCustomerId;

      if (hasData) {
        writeOrderDraftToStorage({
          savedAt: new Date().toISOString(),
          draft: snapshot,
        });
      }
    }

    if (typeof onClose === "function") {
      onClose();
    }
  }, [isEditing, buildDraftSnapshot, onClose]);

  useEffect(() => {
    if (!isOpen) {
      draftRestoredRef.current = false;
      return;
    }
    if (isEditing || draftRestoredRef.current) return;
    if (customerMode === "registered" && customers.length === 0) return;

    const stored = readOrderDraftFromStorage();
    if (!stored || !stored.draft) return;

    applyDraftSnapshot(stored.draft);
    draftRestoredRef.current = true;
  }, [
    isOpen,
    isEditing,
    customerMode,
    customers.length,
    applyDraftSnapshot,
  ]);

  // Quando troca para balcão, zera taxa; quando é delivery, recalc pela distância
  useEffect(() => {
    if (orderType === "counter") {
      setDeliveryFee("0");
      setDeliveryNeighborhood("");
      setSelectedDeliveryRangeId("");
      return;
    }

    if (orderType === "delivery" && deliveryConfig) {
      const range = findDeliveryRangeForKm(
        deliveryDistanceKm,
        deliveryConfig
      );
 const fee = range ? Number(range.price || 0) : 0;

 setSelectedDeliveryRangeId(range ? range.id || "" : "");
 setDeliveryFee(fee ? String(fee).replace(".", ",") : "0");
 setDeliveryNeighborhood(range ? range.label || "" : "");
    }
  }, [orderType, deliveryDistanceKm, deliveryConfig, deliveryConfig.ranges]);

  // -----------------------------
  // Ação: calcular distância usando endereço do cliente
  // -----------------------------
  const handleAutoDistanceFromCustomer = useCallback(async (customerParam, neighborhoodOverride) => {
    const customer = customerParam || selectedCustomer;
    const neighborhoodValue =
      neighborhoodOverride || deliveryAddressNeighborhood;

    if (orderType !== "delivery" || !customer || !customer.address) {
      setDistanceError("Selecione um cliente para entrega.");
      return;
    }

    const addr = normalizeAddressParts(customer.address, neighborhoodValue);
    const missing = getMissingAddressFields(addr, neighborhoodValue);
    if (missing.length > 0) {
      setDistanceError(
        `Endereço incompleto. Faltam: ${missing.join(", ")}.`
      );
      return;
    }
    const parts = [];

    if (addr.street) {
      let line1 = addr.street;
      if (addr.number) line1 += `, ${addr.number}`;
      parts.push(line1);
    }

    const neighborhood = addr.neighborhood;
    if (neighborhood) parts.push(neighborhood);
    if (addr.city) parts.push(addr.city);
    if (addr.state) parts.push(addr.state);
    if (addr.cep) parts.push(`CEP ${addr.cep}`);

    const destination = parts.filter(Boolean).join(" - ");

    if (!destination) {
      setDistanceError(
        "Endereço do cliente incompleto. Preencha rua/bairro/cidade para usar o cálculo automático."
      );
      return;
    }

    setIsCalculatingDistance(true);
    setDistanceError("");

    const km = await calculateDistanceKmUsingBridge(
      BASE_DELIVERY_ADDRESS,
      destination
    );

    setIsCalculatingDistance(false);

    if (km === null) {
      setDistanceError(
        "Não foi possível calcular a distância automaticamente. Verifique a integração ou preencha manualmente."
      );
      return;
    }

    const rounded = Math.round(km * 10) / 10; // 1 casa decimal
    const asString = String(rounded).replace(".", ",");

    setDeliveryDistanceKm(asString);
    // efeito de recalcular taxa entra pelo useEffect de orderType/deliveryDistanceKm
  }, [orderType, selectedCustomer, deliveryAddressNeighborhood]);

  useEffect(() => {
    if (customerMode !== "registered") return;
    if (!selectedCustomer || !activeCustomerAddress) return;
    const addr = normalizeAddressParts(activeCustomerAddress);
    const cepDigits = digitsOnly(addr.cep || "");
    const hasCep = cepDigits.length === 8;
    const missingCityState = !addr.city || !addr.state;
    const canLookupByCep = hasCep && missingCityState;
    const canLookupByAddress =
      !hasCep && addr.street && addr.city && addr.state;

    if (!canLookupByCep && !canLookupByAddress) return;

    const key = [
      selectedCustomer.id,
      selectedCustomerAddressId,
      cepDigits,
      addr.street || "",
      addr.neighborhood || "",
      addr.city || "",
      addr.state || "",
    ].join("|");

    if (lastAddressSyncRef.current === key) return;
    lastAddressSyncRef.current = key;

    let cancelled = false;

    const syncAddress = async () => {
      setIsSyncingCustomerAddress(true);
      try {
        const lookupData = await retryLookup(
          () =>
            canLookupByCep
              ? lookupCep(cepDigits)
              : lookupCepByAddress({
                  street: addr.street,
                  city: addr.city,
                  state: addr.state,
                }),
          { retries: 2, delayMs: 800 }
        );

        const patch = {
          cep: addr.cep || lookupData.cep,
          street: addr.street || lookupData.street,
          neighborhood: addr.neighborhood || lookupData.neighborhood,
          city: addr.city || lookupData.city,
          state: addr.state || lookupData.state,
        };

        const updatedAddress = {
          ...activeCustomerAddress,
          ...patch,
        };

        let updatedCustomer = null;
        if (selectedCustomerAddressId === "primary") {
          updatedCustomer = await updateCustomerRecord(selectedCustomer.id, {
            address: updatedAddress,
          });
        } else {
          const updatedAddresses = customerAltAddresses.map((item) =>
            String(item.id) === String(selectedCustomerAddressId)
              ? { ...item, ...updatedAddress }
              : item
          );
          updatedCustomer = await updateCustomerRecord(selectedCustomer.id, {
            addresses: updatedAddresses,
          });
        }

        if (cancelled || !updatedCustomer) return;

        const nextNeighborhood =
          updatedAddress.neighborhood || updatedAddress.bairro || "";
        if (nextNeighborhood) {
          setDeliveryAddressNeighborhood(nextNeighborhood);
        }

        if (orderType === "delivery") {
          lastDistanceCalcRef.current = [
            selectedCustomer.id,
            selectedCustomerAddressId,
            nextNeighborhood || deliveryNeighborhoodValue,
            updatedAddress.cep || "",
            updatedAddress.street || "",
            updatedAddress.number || "",
            updatedAddress.city || "",
            updatedAddress.state || "",
          ].join("|");
          await handleAutoDistanceFromCustomer(
            { ...updatedCustomer, address: updatedAddress },
            nextNeighborhood || deliveryNeighborhoodValue
          );
        }
      } catch (err) {
        console.error("[OrderFormModal] Erro ao buscar CEP:", err);
      } finally {
        if (!cancelled) setIsSyncingCustomerAddress(false);
      }
    };

    void syncAddress();

    return () => {
      cancelled = true;
    };
  }, [
    customerMode,
    selectedCustomer,
    selectedCustomerAddressId,
    activeCustomerAddress,
    customerAltAddresses,
    orderType,
    deliveryNeighborhoodValue,
    updateCustomerRecord,
    handleAutoDistanceFromCustomer,
  ]);

  useEffect(() => {
    if (customerMode !== "registered") return;
    if (orderType !== "delivery") return;
    if (!selectedCustomer || !activeCustomerAddress) return;
    if (missingAddressFields.length > 0) return;
    if (isCalculatingDistance) return;

    const key = [
      selectedCustomer.id,
      selectedCustomerAddressId,
      deliveryNeighborhoodValue,
      activeCustomerAddress.cep || "",
      activeCustomerAddress.street || "",
      activeCustomerAddress.number || "",
      activeCustomerAddress.city || "",
      activeCustomerAddress.state || "",
    ].join("|");

    if (lastDistanceCalcRef.current === key) return;
    lastDistanceCalcRef.current = key;

    void handleAutoDistanceFromCustomer(
      { ...selectedCustomer, address: activeCustomerAddress },
      deliveryNeighborhoodValue
    );
  }, [
    customerMode,
    orderType,
    selectedCustomer,
    activeCustomerAddress,
    selectedCustomerAddressId,
    deliveryNeighborhoodValue,
    missingAddressFields.length,
    isCalculatingDistance,
    handleAutoDistanceFromCustomer,
  ]);

  // -----------------------------
  // Filtro de pizzas e drinks
  // -----------------------------
  const filteredPizzas = useMemo(() => {
    const t = flavorSearch.trim().toLowerCase();
    if (!t) return pizzaCatalog;

    return pizzaCatalog.filter(
      (p) =>
        (p.name || "").toLowerCase().includes(t) ||
        (p.description || "").toLowerCase().includes(t) ||
        (p.categoria || "").toLowerCase().includes(t)
    );
  }, [pizzaCatalog, flavorSearch]);

  const filteredDrinks = useMemo(() => {
    const t = drinkSearch.trim().toLowerCase();
    if (!t) return drinkCatalog;

    return drinkCatalog.filter(
      (d) =>
        (d.name || "").toLowerCase().includes(t) ||
        (d.description || "").toLowerCase().includes(t) ||
        (d.categoria || "").toLowerCase().includes(t)
    );
  }, [drinkCatalog, drinkSearch]);

  // pizzas selecionadas (para mostrar nome nos chips)
  const flavor1Pizza = useMemo(
 () => (flavor1 ? findById(flavor1, pizzaCatalog) : null),
    [flavor1, pizzaCatalog]
  );
  const flavor2Pizza = useMemo(
 () => (flavor2 ? findById(flavor2, pizzaCatalog) : null),
    [flavor2, pizzaCatalog]
  );
  const flavor3Pizza = useMemo(
 () => (flavor3 ? findById(flavor3, pizzaCatalog) : null),
    [flavor3, pizzaCatalog]
  );

  // -----------------------------
  // Extras selecionados
  // -----------------------------
  const extrasUnitTotal = useMemo(() => {
    if (!selectedExtras.length || !extraCatalog.length) return 0;

    return selectedExtras.reduce((acc, extraId) => {
      const extra = findById(extraId, extraCatalog);
      if (!extra) return acc;

      const price =
        size === "broto"
           ? extra.prices.broto || extra.prices.grande || 0
          : extra.prices.grande || extra.prices.broto || 0;

      return acc + (price || 0);
    }, 0);
  }, [selectedExtras, extraCatalog, size]);

  // -----------------------------
  // Preço unitário da pizza
  // -----------------------------
  const unitPizzaPrice = useMemo(() => {
    const pizza1 = findById(flavor1, pizzaCatalog);
    if (!pizza1) return 0;

    const basePrice1 = pizza1.prices[size] || 0;

    if (
      (!twoFlavorsEnabled && !threeFlavorsEnabled) ||
      (!flavor2 && !flavor3)
    ) {
      const selectedCrustObj = pizzaCrusts.find(c => c.id === selectedCrust);
      const crustPrice = selectedCrustObj ? selectedCrustObj.price : 0;
      return basePrice1 + extrasUnitTotal + crustPrice;
    }

    const prices = [basePrice1];

    if (twoFlavorsEnabled && flavor2) {
      const pizza2 = findById(flavor2, pizzaCatalog);
      const basePrice2 = pizza2.prices[size] || 0;
      if (basePrice2) prices.push(basePrice2);
    }

    if (threeFlavorsEnabled && flavor3) {
      const pizza3 = findById(flavor3, pizzaCatalog);
      const basePrice3 = pizza3.prices[size] || 0;
      if (basePrice3) prices.push(basePrice3);
    }

    const base = Math.max(...prices);
    const selectedCrustObj = pizzaCrusts.find(c => c.id === selectedCrust);
    const crustPrice = selectedCrustObj ? selectedCrustObj.price : 0;

    return base + extrasUnitTotal + crustPrice;
  }, [
    flavor1,
    flavor2,
    flavor3,
    size,
    pizzaCatalog,
    twoFlavorsEnabled,
    threeFlavorsEnabled,
    extrasUnitTotal,
    selectedCrust,
    pizzaCrusts,
  ]);

  // -----------------------------
  // Seleção de sabores via cards
  // -----------------------------
  const handleSelectFlavorCard = (pizzaId) => {
    if (!pizzaId) return;

    if (
      activeFlavorSlot === "flavor2" &&
      !(twoFlavorsEnabled || threeFlavorsEnabled)
    ) {
      setActiveFlavorSlot("flavor1");
    }
    if (activeFlavorSlot === "flavor3" && !threeFlavorsEnabled) {
      setActiveFlavorSlot("flavor1");
    }

    if (activeFlavorSlot === "flavor1") {
      setFlavor1(pizzaId);
    } else if (
      activeFlavorSlot === "flavor2" &&
      (twoFlavorsEnabled || threeFlavorsEnabled)
    ) {
      setFlavor2(pizzaId);
    } else if (activeFlavorSlot === "flavor3" && threeFlavorsEnabled) {
      setFlavor3(pizzaId);
    } else {
      setFlavor1(pizzaId);
      setActiveFlavorSlot("flavor1");
    }
  };

  const handleToggleExtra = (extraId) => {
    setSelectedExtras((prev) =>
      prev.includes(extraId)
         ? prev.filter((id) => id !== extraId)
        : [...prev, extraId]
    );
  };

  // -----------------------------
  // Adicionar pizza à lista
  // -----------------------------
  const handleAddPizza = () => {
    if (!pizzaCatalog.length) {
      emitToast({ type: "warning", message: "Nenhuma pizza cadastrada." });
      return false;
    }

    const q = Number(quantity) || 0;
    if (q <= 0) {
      emitToast({ type: "warning", message: "Quantidade invalida." });
      return false;
    }

    const pizza1 = findById(flavor1, pizzaCatalog);
    if (!pizza1) {
      emitToast({ type: "warning", message: "Selecione ao menos o 1o sabor." });
      return false;
    }

    let pizza2 = null;
    if (twoFlavorsEnabled || threeFlavorsEnabled) {
      if (!flavor2) {
        emitToast({ type: "warning", message: "Selecione o 2o sabor ou volte para 1 sabor." });
        return false;
      }
      pizza2 = findById(flavor2, pizzaCatalog);
      if (!pizza2) {
        emitToast({ type: "warning", message: "Sabor 2 invalido." });
        return false;
      }
    }

    let pizza3 = null;
    if (threeFlavorsEnabled) {
      if (!flavor3) {
        emitToast({ type: "warning", message: "Selecione o 3o sabor ou volte para 1/2 sabores." });
        return false;
      }
      pizza3 = findById(flavor3, pizzaCatalog);
      if (!pizza3) {
        emitToast({ type: "warning", message: "Sabor 3 invalido." });
        return false;
      }
    }

    const sizeLabel = size === "broto" ? "Broto" : "Grande";
    const lineUnit = unitPizzaPrice;
    const lineTotal = lineUnit * q;

    const extrasDetail = selectedExtras
      .map((extraId) => {
        if (extraId.startsWith('ingredient_')) {
          const index = parseInt(extraId.replace('ingredient_', ''));
          const ingredient = pizzaIngredients[index];
          if (!ingredient) return null;
          return {
            id: extraId,
            name: ingredient.name,
            unitPrice: ingredient.basePrice,
            total: ingredient.basePrice * q,
          };
        }

        const extra = findById(extraId, extraCatalog);
        if (!extra) return null;
        const price =
          size === "broto"
            ? extra.prices.broto || extra.prices.grande || 0
            : extra.prices.grande || extra.prices.broto || 0;
        return {
          id: extra.id,
          name: extra.name,
          unitPrice: price,
          total: price * q,
        };
      })
      .filter(Boolean);

    const newItem = {
      lineId:
        editingItem && editingItem.kind === "pizza"
          ? editingItem.lineId
          : `line-${Date.now()}-${Math.floor(Math.random() * 10000)}`,
      kind: "pizza",
      size,
      sizeLabel,
      quantity: q,
      flavor1Id: pizza1.id,
      flavor1Name: pizza1.name,
      flavor2Id: pizza2 ? pizza2.id : null,
      flavor2Name: pizza2 ? pizza2.name : null,
      flavor3Id: pizza3 ? pizza3.id : null,
      flavor3Name: pizza3 ? pizza3.name : null,
      twoFlavors: !!pizza2,
      threeFlavors: !!pizza3,
      crustId: selectedCrust,
      crustName:
        pizzaCrusts.find((c) => c && c.id === selectedCrust)?.name ||
        "Tradicional",
      crustPrice:
        pizzaCrusts.find((c) => c && c.id === selectedCrust)?.price || 0,
      extras: extrasDetail,
      unitPrice: lineUnit,
      total: lineTotal,
    };

    setOrderItems((prev) => {
      if (editingItem && editingItem.kind === "pizza") {
        let replaced = false;
        const next = prev.map((item) => {
          if (item.lineId === editingItem.lineId) {
            replaced = true;
            return newItem;
          }
          return item;
        });
        return replaced ? next : [...next, newItem];
      }
      return [...prev, newItem];
    });

    setQuantity(1);
    setTwoFlavorsEnabled(false);
    setThreeFlavorsEnabled(false);
    setFlavor2("");
    setFlavor3("");
    setSelectedExtras([]);
    setExtrasOpen(false);
    setActiveFlavorSlot("flavor1");

    if (editingItem && editingItem.kind === "pizza") {
      setEditingItem(null);
    }

    return true;
  };

  // -----------------------------
  // Adicionar bebida
  // -----------------------------
  useEffect(() => {
    if (!showDrinkModal) return;
    if (selectedDrinkId || !drinkCatalog.length) return;
    setSelectedDrinkId(drinkCatalog[0].id || "");
  }, [showDrinkModal, selectedDrinkId, drinkCatalog]);

  const handleEditItem = (item) => {
    if (!item) return;
    setEditingItem({ lineId: item.lineId, kind: item.kind });
    setShowOrderItemsModal(false);

    if (item.kind === "pizza") {
      setShowDrinkModal(false);
      setShowPizzaModal(true);
      setSize(item.size || "grande");
      setQuantity(Number(item.quantity) || 1);
      setTwoFlavorsEnabled(Boolean(item.twoFlavors || item.threeFlavors));
      setThreeFlavorsEnabled(Boolean(item.threeFlavors));
      setFlavor1(item.flavor1Id || "");
      setFlavor2(item.flavor2Id || "");
      setFlavor3(item.flavor3Id || "");
      setSelectedCrust(item.crustId || selectedCrust);
      setSelectedExtras(
        Array.isArray(item.extras)
          ? item.extras
              .map((extra) => (extra?.id != null ? String(extra.id) : ""))
              .filter(Boolean)
          : []
      );
      setFlavorSearch("");
      setActiveFlavorSlot("flavor1");
      return;
    }

    if (item.kind === "drink") {
      setShowPizzaModal(false);
      setShowDrinkModal(true);
      let resolvedId = item.productId || "";
      if (!resolvedId && item.productName) {
        const match = drinkCatalog.find(
          (drink) =>
            (drink.name || "").toLowerCase() ===
            String(item.productName).toLowerCase()
        );
        if (match) resolvedId = match.id;
      }
      setSelectedDrinkId(resolvedId);
      setDrinkQuantity(Number(item.quantity) || 1);
      setDrinkSearch("");
    }
  };

  const handleShowPizzaModal = (next) => {
    if (next) {
      setEditingItem(null);
    }
    setShowPizzaModal(next);
  };

  const handleShowDrinkModal = (next) => {
    if (next) {
      setEditingItem(null);
    }
    setShowDrinkModal(next);
  };

  const handleClosePizzaModal = () => {
    setShowPizzaModal(false);
    if (editingItem && editingItem.kind === "pizza") {
      setEditingItem(null);
    }
  };

  const handleCloseDrinkModal = () => {
    setShowDrinkModal(false);
    if (editingItem && editingItem.kind === "drink") {
      setEditingItem(null);
    }
  };

  const handleAddDrink = () => {
    if (!drinkCatalog.length) {
      emitToast({ type: "warning", message: "Nenhuma bebida cadastrada." });
      return false;
    }

    const q = Number(drinkQuantity) || 0;
    if (q <= 0) {
      emitToast({ type: "warning", message: "Quantidade invÁlida." });
      return false;
    }

    const drink = findById(selectedDrinkId, drinkCatalog);
    if (!drink) {
      emitToast({ type: "warning", message: "Selecione uma bebida." });
      return false;
    }

    const unit = drink.prices.grande || drink.prices.broto || 0;

    if (!unit) {
      emitToast({ type: "warning", message: "Bebida sem preÇo configurado." });
      return false;
    }

    const newItem = {
      lineId:
        editingItem && editingItem.kind === "drink"
          ? editingItem.lineId
          : `line-${Date.now()}-${Math.floor(Math.random() * 10000)}`,
      kind: "drink",
      productId: drink.id,
      productName: drink.name,
      quantity: q,
      unitPrice: unit,
      total: unit * q,
    };

    setOrderItems((prev) => {
      if (editingItem && editingItem.kind === "drink") {
        let replaced = false;
        const next = prev.map((item) => {
          if (item.lineId === editingItem.lineId) {
            replaced = true;
            return newItem;
          }
          return item;
        });
        return replaced ? next : [...next, newItem];
      }
      return [...prev, newItem];
    });

    setDrinkQuantity(1);
    if (editingItem && editingItem.kind === "drink") {
      setEditingItem(null);
    }
    return true;
  };

  const handleRemoveItem = (lineId) => {
    setOrderItems((prev) => prev.filter((it) => it.lineId !== lineId));
  };

  const handleOrderTypeChange = (value) => {
    if (value === "delivery" && deliveryTypeBlockedReason) {
      setDistanceError(deliveryTypeBlockedReason);
      return;
    }
    if (value !== "delivery") {
      setDistanceError("");
    }
    setOrderType(value);
  };

  // -----------------------------
  // Totais
  // -----------------------------
  const subtotal = useMemo(
    () => orderItems.reduce((acc, it) => acc + (it.total || 0), 0),
    [orderItems]
  );

  const totalItems = useMemo(
    () => orderItems.reduce((acc, it) => acc + (Number(it.quantity) || 0), 0),
    [orderItems]
  );

  const baseDeliveryFeeNumber = useMemo(
    () => Number(String(deliveryFee).replace(",", ".")) || 0,
    [deliveryFee]
  );

  const peakFeeNumber = useMemo(() => {
    if (orderType !== "delivery") return 0;
    const peak = deliveryConfig.peakFee;
    if (!isWithinPeakWindow(peak)) return 0;
    const amount =
 typeof peak.amount === "number" ? peak.amount : Number(peak.amount || 0);
 return Number.isNaN(amount) ? 0 : amount;
  }, [orderType, deliveryConfig.peakFee]);

  const deliveryFeeNumber = useMemo(
    () => baseDeliveryFeeNumber + peakFeeNumber,
    [baseDeliveryFeeNumber, peakFeeNumber]
  );

  const discountRaw = useMemo(
    () => Number(String(discountValue).replace(",", ".")) || 0,
    [discountValue]
  );

  const discountAmount = useMemo(() => {
    if (discountType === "value") {
      return Math.min(discountRaw, subtotal + deliveryFeeNumber);
    }
    if (discountType === "percent") {
      if (discountRaw <= 0) return 0;
      const base = subtotal + deliveryFeeNumber;
      return (base * discountRaw) / 100;
    }
    return 0;
  }, [discountType, discountRaw, subtotal, deliveryFeeNumber]);

  const total = useMemo(
    () => Math.max(subtotal + deliveryFeeNumber - discountAmount, 0),
    [subtotal, deliveryFeeNumber, discountAmount]
  );

  const cashGivenNumber = useMemo(
    () => Number(String(cashGiven).replace(",", ".")) || 0,
    [cashGiven]
  );

  const changeAmount = useMemo(
    () => Math.max(cashGivenNumber - total, 0),
    [cashGivenNumber, total]
  );

  const minOrderValueNumber =
    typeof deliveryConfig.minOrderValue === "number"
      ? deliveryConfig.minOrderValue
      : Number(deliveryConfig.minOrderValue || 0);

  const maxDistanceKmNumber =
    typeof deliveryConfig.maxDistanceKm === "number"
      ? deliveryConfig.maxDistanceKm
      : Number(deliveryConfig.maxDistanceKm || 0);

  const etaMinutesFromCustomer =
    selectedCustomer &&
    typeof selectedCustomer.deliveryMinMinutes === "number"
       ? selectedCustomer.deliveryMinMinutes
      : null;

  const etaMinutesRaw =
    typeof etaMinutesFromCustomer === "number" && etaMinutesFromCustomer > 0
       ? etaMinutesFromCustomer
      : typeof deliveryConfig.etaMinutesDefault === "number"
       ? deliveryConfig.etaMinutesDefault
      : Number(deliveryConfig.etaMinutesDefault || 0);

  const etaMinutesValue = Number.isFinite(etaMinutesRaw)
     ? etaMinutesRaw
    : 0;

  const deliveryDistanceNumber = parseKmValue(deliveryDistanceKm);

  const maxDistanceExceeded =
    orderType === "delivery" &&
    maxDistanceKmNumber > 0 &&
    deliveryDistanceNumber > 0 &&
    deliveryDistanceNumber > maxDistanceKmNumber;

  const minOrderNotMet =
    orderType === "delivery" &&
    minOrderValueNumber > 0 &&
    subtotal > 0 &&
    subtotal < minOrderValueNumber;

  const businessHoursMessage =
    businessHoursStatus.reason || "Fora do horário de funcionamento.";

  // -----------------------------
  // Build draft + submit
  // -----------------------------
  const focusSubmitField = (field) => {
    if (!field) return;

    if (field === "customer") {
      setShowCustomerSearch(true);
      setTimeout(() => {
        if (customerSearchRef.current) {
          customerSearchRef.current.focus();
        }
      }, 0);
      return;
    }

    if (field === "counterLabel") {
      if (counterLabelRef.current) {
        counterLabelRef.current.focus();
      }
      return;
    }

    if (field === "items") {
      if (pizzaQuantityRef.current) {
        pizzaQuantityRef.current.focus();
      }
      return;
    }

    if (field === "deliveryNeighborhood") {
      if (deliveryNeighborhoodRef.current) {
        deliveryNeighborhoodRef.current.focus();
      }
      return;
    }

    if (field === "distance") {
      if (distanceSectionRef.current) {
        distanceSectionRef.current.scrollIntoView({
          behavior: "smooth",
          block: "center",
        });
      }
    }
  };

  const buildDraft = () => {
    if (!orderItems.length) {
      return {
        error: "Adicione pelo menos uma pizza ou bebida ao pedido.",
        errorField: "items",
      };
    }

    if (!isEditing && !businessHoursStatus.isOpen) {
      return {
        error: `Horário fechado. ${businessHoursMessage}`,
        errorField: "items",
      };
    }

    let customerName = "";
    let customerId = null;
    let customerPhone = "";
    let customerCpf = "";
    let customerAddress = null;

    if (customerMode === "registered") {
      if (!selectedCustomer) {
        return {
          error: "Selecione um cliente ou troque para Balcão / rápido.",
          errorField: "customer",
        };
      }
      customerId = selectedCustomer.id;
      customerName = selectedCustomer.name || "";
      customerPhone = selectedCustomer.phone || "";
      customerCpf = selectedCustomer.cpf || "";
      if (activeCustomerAddress) {
        const addr = normalizeAddressParts(
          activeCustomerAddress,
          deliveryAddressNeighborhood
        );
        const neighborhoodValue = (addr.neighborhood || "").trim();
        customerAddress = {
          cep: addr.cep || "",
          street: addr.street || "",
          number: addr.number || "",
          complement: activeCustomerAddress.complement || "",
          neighborhood: neighborhoodValue,
          city: addr.city || "",
          state: addr.state || "",
        };
      }
    } else {
      const label = (counterLabel || "").trim();
      if (!label) {
        return {
          error: "Informe uma identificação para Balcão / rápido.",
          errorField: "counterLabel",
        };
      }
      customerName = label;
    }

    if (orderType === "delivery") {
      if (customerMode !== "registered" || !customerAddress) {
        return {
          error: "Selecione um cliente cadastrado para entrega.",
          errorField: "customer",
        };
      }

      const missing = getMissingAddressFields(
        customerAddress,
        customerAddress.neighborhood
      );
      if (missing.length > 0) {
        return {
          error: `Endereço incompleto no cadastro do cliente: ${missing.join(
            ", "
          )}.`,
          errorField: "deliveryNeighborhood",
        };
      }

      const blockedMatch = findBlockedNeighborhood(
        customerAddress.neighborhood,
        deliveryConfig.blockedNeighborhoods
      );
      if (blockedMatch) {
        return {
          error: `Não entregamos no bairro "${blockedMatch}".`,
          errorField: "deliveryNeighborhood",
        };
      }
    }

    if (minOrderNotMet) {
      return {
        error: `Pedido mínimo para entrega: ${formatCurrency(
          minOrderValueNumber
        )}.`,
        errorField: "items",
      };
    }

    if (maxDistanceExceeded) {
      return {
          error: `Distância acima do máximo permitido (${maxDistanceKmNumber} km).`,
          errorField: "distance",
      };
    }

    const summaryLines = orderItems.map((item) => {
      if (item.kind === "pizza") {
        const flavors = [
          item.flavor1Name,
          item.flavor2Name,
          item.flavor3Name,
        ].filter(Boolean);

        const flavorsText =
 flavors.length > 1 ? flavors.join(" / ") : flavors[0] || "Pizza";

        const baseText = `${item.quantity}x ${item.sizeLabel} ${flavorsText}`;

        if (item.extras && item.extras.length > 0) {
          const extrasNames = item.extras.map((ex) => ex.name).join(", ");
          return `${baseText} (Adicionais: ${extrasNames})`;
        }

        return baseText;
      }

      if (item.kind === "drink") {
        return `${item.quantity}x Bebida ${item.productName}`;
      }

      return `${item.quantity}x Item`;
    });

    const summary = summaryLines.join(" | ");

    const draft = {
      status,
      orderType,
      paymentMethod,
      customerMode,
      customerId,
      customerName,
      customerPhone,
      customerCpf,
      customerAddress,
      customerAddressId:
 customerMode === "registered" ? selectedCustomerAddressId : null,
      customerAddressLabel:
 customerMode === "registered" ? activeCustomerAddressLabel : null,
 counterLabel: customerMode === "counter" ? counterLabel.trim() : null,
      items: orderItems,
      subtotal,
      deliveryFee: deliveryFeeNumber,
      deliveryFeeBase: baseDeliveryFeeNumber,
      deliveryPeakFee: peakFeeNumber,
      deliveryNeighborhood:
 orderType === "delivery" ? deliveryNeighborhood || null : null,
      deliveryDistanceKm:
 orderType === "delivery" ? parseKmValue(deliveryDistanceKm) : 0,
      deliveryMinMinutes:
        orderType === "delivery" && etaMinutesValue > 0
           ? etaMinutesValue
          : null,
      discount: {
        type: discountType,
        value: discountRaw,
        amount: discountAmount,
      },
      total,
      cash: {
        enabled: paymentMethod === "money",
 cashGiven: paymentMethod === "money" ? cashGivenNumber : 0,
 changeAmount: paymentMethod === "money" ? changeAmount : 0,
      },
      orderNotes,
      kitchenNotes,
      summary,
      meta: {
        totalItems,
      },
    };

    return { draft };
  };

  const handleSubmit = (e, options = { action: "save" }) => {
    if (e && e.preventDefault) e.preventDefault();

    const { draft, error, errorField } = buildDraft();
    if (error) {
      setSubmitError(error);
      emitToast({ type: "warning", message: error });
      focusSubmitField(errorField);
      return;
    }
    setSubmitError("");

    if (typeof onConfirm === "function") {
      if (!isEditing) {
        clearOrderDraftStorage();
      }
      onConfirm(draft, options);
    }
  };

  // -----------------------------
  // Keyboard shortcuts
  // -----------------------------
  useEffect(() => {
    if (!isOpen) return;

    const handleKeyDown = (e) => {
      // Ignore if user is typing in an input
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
        // Allow Ctrl+S for draft saving even when typing
        if (e.ctrlKey && e.key === 's') {
          e.preventDefault();
          const { draft } = buildDraft();
          if (draft) {
            writeOrderDraftToStorage({ 
              draft, 
              timestamp: Date.now(),
              version: '1.0'
            });
            emitToast({ 
              type: "success", 
              message: "Rascunho salvo com sucesso!",
              duration: 3000
            });
          }
          return;
        }
        return;
      }

      switch (e.key) {
        case 'F5':
          e.preventDefault();
          if (totalItems > 0) {
            setShowPaymentModal(true);
          }
          break;
        case 'F9':
          e.preventDefault();
          if (totalItems > 0) {
            handleSubmit(null, { action: "save_and_print" });
          }
          break;
        case 'F10':
          e.preventDefault();
          if (totalItems > 0) {
            handleSubmit(null, { action: "save" });
          }
          break;
        case 'F12':
          e.preventDefault();
          setShowOrderOptionsModal(true);
          break;
        case 'Escape':
          e.preventDefault();
          handleClose();
          break;
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [isOpen, totalItems, handleSubmit, handleClose]);

  // -----------------------------
  // Auto-save draft functionality
  // -----------------------------
  useEffect(() => {
    if (!isOpen || isEditing) return;

    const autoSaveInterval = setInterval(() => {
      const { draft } = buildDraft();
      if (draft && totalItems > 0) {
        writeOrderDraftToStorage({ 
          draft, 
          timestamp: Date.now(),
          version: '1.0',
          autoSave: true
        });
        setLastAutoSave(new Date());
        console.log('[OrderForm] Auto-saved draft');
      }
    }, 30000); // Auto-save every 30 seconds

    return () => clearInterval(autoSaveInterval);
  }, [isOpen, isEditing, totalItems]);

  // -----------------------------
  // Click outside handler for customer search
  // -----------------------------
  useEffect(() => {
    const handleClickOutside = (e) => {
      if (showCustomerSearch && customerSearch) {
        const searchContainer = e.target.closest('.customer-selection');
        if (!searchContainer) {
          setShowCustomerSearch(false);
        }
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, [showCustomerSearch, customerSearch]);

  useEffect(() => {
    if (!submitError) return;
    setSubmitError("");
  }, [
    submitError,
    orderItems,
    selectedCustomerId,
    counterLabel,
    orderType,
    deliveryAddressNeighborhood,
    deliveryDistanceKm,
    minOrderNotMet,
    maxDistanceExceeded,
    businessHoursStatus.isOpen,
  ]);

  if (!isOpen) return null;

  const editingOrderReference = isEditing
    ? initialOrder.shortId ||
      initialOrder.id ||
      initialOrder._id ||
      null
    : null;
  const modalTitleText = isEditing ? "Editar pedido" : "Novo pedido";
  const modalSubtitleText = isEditing
    ? editingOrderReference
      ? `Atualize o pedido ${editingOrderReference}.`
      : "Atualize o pedido existente."
    : "Selecione o cliente, monte os itens e já veja totais e entrega em tempo real.";

  const hasCustomers = customers.length > 0;
  const hasPizzas = pizzaCatalog.length > 0;
  const hasDrinks = drinkCatalog.length > 0;
  const hasExtras = extraCatalog.length > 0;

  const extrasDisabled = !hasPizzas || !flavor1;

  // -----------------------------
  // Render
  // -----------------------------
  return (
    <>
      <div className="modal-backdrop">
      <div className="modal-window orderform-modal">
        {/* HEADER */}
          <div className="modal-header">
            <div>
              <div className="modal-eyebrow">
                {isEditing ? "Pedido em edição" : "Pedido em andamento"}
              </div>
              <div className="modal-title">{modalTitleText}</div>
              <div className="modal-subtitle">{modalSubtitleText}</div>
              {isLoading && (
                <div className="modal-helper-text">
                  Carregando clientes e produtos...
                </div>
              )}
              {!businessHoursStatus.isOpen && (
                <div className="field-error-text orderform-banner">
                  Loja fechada: {businessHoursMessage}
                </div>
              )}
              {orderType === "delivery" && minOrderNotMet && (
                <div className="field-error-text orderform-banner">
                  Pedido mínimo para entrega:{" "}
                  {formatCurrency(minOrderValueNumber)}.
                </div>
              )}
              {orderType === "delivery" && blockedNeighborhoodMatch && (
                <div className="field-error-text orderform-banner">
                  Bairro bloqueado para entrega: {blockedNeighborhoodMatch}.
                </div>
              )}
              {submitError && (
                <div className="field-error-text orderform-banner">
                  {submitError}
                </div>
              )}
            {loadError && <div className="modal-error-text">{loadError}</div>}
          </div>
          <button className="modal-close" onClick={handleClose} aria-label="Fechar">
            <OrderIcon name="close" />
          </button>
        </div>

        {/* MODULAR BUTTON GRID */}
        <div className="orderform-modular-grid">
          {/* Order Summary Card */}
          <div className="modular-card summary-card">
            <div className="card-header">
              <h3><OrderIcon name="summary" /> Resumo do Pedido</h3>
              <span className="status-badge status-open">Em Aberto</span>
            </div>
            <div className="card-content">
              <div className="summary-row">
                <span className="label">Número do Pedido:</span>
                <span className="value">#{isEditing ? (initialOrder?.shortId || "Edit") : "Novo"}</span>
              </div>
              <div className="summary-row">
                <span className="label">Tipo:</span>
                <span className="value">
                  {orderType === "delivery" ? "🛵 Delivery" : "🏃 Balcão"}
                </span>
              </div>
              <div className="summary-row">
                <span className="label">Itens:</span>
                <span className="value">{totalItems} {totalItems === 1 ? 'item' : 'itens'}</span>
              </div>
              <div className="summary-row">
                <span className="label">Subtotal:</span>
                <span className="value">{formatCurrency(total - deliveryFeeNumber)}</span>
              </div>
              <div className="summary-row">
                <span className="label">Taxa de Entrega:</span>
                <span className="value">
                  {orderType === "delivery" ? formatCurrency(deliveryFeeNumber) : "Grátis"}
                </span>
              </div>
              <div className="summary-row">
                <span className="label">Total:</span>
                <span className="value highlight">{formatCurrency(total)}</span>
              </div>
              
              {/* Auto-save indicator */}
              {lastAutoSave && (
                <div className="summary-row autosave-indicator">
                  <span className="label">💾 Auto-salvo:</span>
                  <span className="value" style={{ fontSize: '11px', color: 'var(--success)' }}>
                    {lastAutoSave.toLocaleTimeString('pt-BR')}
                  </span>
                </div>
              )}
              
              {/* Additional Information */}
              {deliveryDistanceKm && (
                <div className="summary-row">
                  <span className="label">Distância:</span>
                  <span className="value">{deliveryDistanceKm} km</span>
                </div>
              )}
              
              {orderNotes && (
                <div className="summary-row">
                  <span className="label">Observações:</span>
                  <span className="value" style={{ fontSize: '12px', fontStyle: 'italic' }}>
                    {orderNotes.length > 30 ? orderNotes.substring(0, 30) + '...' : orderNotes}
                  </span>
                </div>
              )}
            </div>
            <div className="card-actions">
              <button 
                type="button" 
                className="btn btn-primary btn-block"
                onClick={() => setShowOrderItemsModal(true)}
              >
                <OrderIcon name="edit" />
                Gerenciar Itens ({totalItems})
              </button>
            </div>
          </div>

          {/* Customer Info Card */}
          <div className="modular-card customer-card">
            <div className="card-header">
              <h3><OrderIcon name="user" /> Informações do Cliente</h3>
              <span className="status-badge" style={{
                background: customerMode === "registered" ? "rgba(16, 185, 129, 0.1)" : "rgba(245, 158, 11, 0.1)",
                color: customerMode === "registered" ? "var(--success)" : "var(--warning)",
                borderColor: customerMode === "registered" ? "rgba(16, 185, 129, 0.2)" : "rgba(245, 158, 11, 0.2)"
              }}>
                {customerMode === "registered" ? "👤 Cadastrado" : "🏃 Balcão"}
              </span>
            </div>
            <div className="card-content">
              {/* Customer Selection Interface */}
              {customerMode === "registered" && (
                <div className="customer-selection">
                  <div className="customer-search-wrapper">
                    <div className="field-input-with-icon">
                      <input
                        ref={customerSearchRef}
                        className="field-input"
                        type="text"
                        placeholder="🔍 Buscar cliente por nome, telefone ou CPF..."
                        value={customerSearch}
                        onChange={(e) => setCustomerSearch(e.target.value)}
                        onFocus={() => setShowCustomerSearch(true)}
                      />
                      {customerSearch && (
                        <button
                          type="button"
                          className="field-clear-btn"
                          onClick={() => {
                            setCustomerSearch("");
                            setSelectedCustomerId(null);
                          }}
                        >
                          ✕
                        </button>
                      )}
                    </div>
                  </div>
                  
                  {showCustomerSearch && customerSearch && (
                    <div className="customer-search-results">
                      {filteredCustomers.length > 0 ? (
                        filteredCustomers.slice(0, 5).map((customer) => (
                          <button
                            key={customer.id}
                            type="button"
                            className="customer-result-item"
                            onClick={() => {
                              setSelectedCustomerId(customer.id);
                              setCustomerSearch("");
                              setShowCustomerSearch(false);
                            }}
                          >
                            <div className="customer-result-name">
                              {customer.name}
                            </div>
                            <div className="customer-result-details">
                              📞 {customer.phone} {customer.cpf && `• 📋 ${customer.cpf}`}
                            </div>
                          </button>
                        ))
                      ) : (
                        <div className="customer-result-empty">
                          Nenhum cliente encontrado para "{customerSearch}"
                        </div>
                      )}
                    </div>
                  )}
                  
                  {!customerSearch && (
                    <div className="customer-quick-actions">
                      <button
                        type="button"
                        className="btn btn-ghost btn-sm"
                        onClick={openCustomerModal}
                      >
                        <OrderIcon name="search" />
                        Buscar cliente avançado
                      </button>
                      <button
                        type="button"
                        className="btn btn-ghost btn-sm"
                        onClick={openCustomerEditModal}
                      >
                        <OrderIcon name="plus" />
                        Novo cliente
                      </button>
                    </div>
                  )}
                </div>
              )}
              
              {/* Customer Display */}
              <div className="customer-info">
                <div className="customer-name">
                  {customerMode === "registered" && selectedCustomer
                    ? selectedCustomer.name
                    : counterLabel || "Cliente não informado"}
                </div>
                {customerMode === "registered" && selectedCustomer && (
                  <div className="customer-details">
                    <span>📞 {selectedCustomer.phone}</span>
                    <span>🆔 ID: {selectedCustomer.id}</span>
                    {selectedCustomer.cpf && <span>📋 CPF: {selectedCustomer.cpf}</span>}
                    {selectedCustomer.addresses && selectedCustomer.addresses.length > 0 && (
                      <span>📍 {selectedCustomer.addresses.length} endereço(s)</span>
                    )}
                  </div>
                )}
                {customerMode === "counter" && counterLabel && (
                  <div className="customer-details">
                    <span>🏃 Identificação rápida</span>
                    <span>⚡ Sem cadastro necessário</span>
                  </div>
                )}
              </div>
            </div>
            <div className="card-actions">
              <div className="btn-group">
                <button 
                  type="button" 
                  className="btn btn-outline"
                  onClick={openCustomerModal}
                >
                  <OrderIcon name="edit" />
                  Editar
                </button>
                <button 
                  type="button" 
                  className="btn btn-outline"
                  onClick={() => {
                    if (!selectedCustomer) {
                      emitToast({ type: "warning", message: "Selecione um cliente para ver o histórico." });
                      return;
                    }
                    openCustomerHistoryModal();
                  }}
                >
                  <OrderIcon name="history" />
                  Histórico
                </button>
              </div>
            </div>
          </div>

          {/* Delivery Address Card */}
          <div className="modular-card address-card">
            <div className="card-header">
              <h3><OrderIcon name="pin" /> Endereço de Entrega</h3>
              <span className="status-badge" style={{
                background: activeCustomerAddress ? "rgba(16, 185, 129, 0.1)" : "rgba(239, 68, 68, 0.1)",
                color: activeCustomerAddress ? "var(--success)" : "var(--danger)",
                borderColor: activeCustomerAddress ? "rgba(16, 185, 129, 0.2)" : "rgba(239, 68, 68, 0.2)"
              }}>
                {activeCustomerAddress ? "📍 Definido" : "⚠️ Não definido"}
              </span>
            </div>
            <div className="card-content">
              <div className="address-info">
                {activeCustomerAddress ? (
                  <>
                    <div className="address-display">
                      <strong>{activeCustomerAddress.street}, {activeCustomerAddress.number}</strong>
                      {activeCustomerAddress.complement && <span> - {activeCustomerAddress.complement}</span>}
                      <br />
                      {activeCustomerAddress.neighborhood} - {activeCustomerAddress.city}/{activeCustomerAddress.state}
                      {activeCustomerAddress.cep && <span> • CEP: {activeCustomerAddress.cep}</span>}
                    </div>
                    
                    {/* Map and Delivery Info */}
                    <div className="address-map-info">
                      <div className="delivery-info">
                        <div className="delivery-info-item">
                          <OrderIcon name="distance" />
                          <span className="delivery-distance">
                            {deliveryDistanceKm ? `${deliveryDistanceKm} km` : "Calculando..."}
                          </span>
                        </div>
                        
                        <div className="delivery-info-item">
                          <OrderIcon name="clock" />
                          <span className="delivery-time">
                            {deliveryDistanceKm ? `${Math.ceil(parseFloat(deliveryDistanceKm) * 8)} min` : "Aguardando..."}
                          </span>
                        </div>
                        
                        <div className="delivery-info-actions">
                          <MapLink
                            address={activeCustomerAddress}
                            storeAddress={storeAddress}
                            type="delivery"
                            size="sm"
                            showLabel={false}
                          />
                        </div>
                      </div>
                    </div>
                  </>
                ) : (
                  <div className="address-display" style={{ 
                    background: "rgba(239, 68, 68, 0.05)", 
                    borderLeft: "3px solid var(--danger)",
                    padding: "16px",
                    textAlign: "center",
                    fontStyle: "italic",
                    color: "var(--danger)"
                  }}>
                    ⚠️ Nenhum endereço de entrega definido
                    <br />
                    <small>Selecione um cliente e defina um endereço para continuar</small>
                  </div>
                )}
              </div>
            </div>
            <div className="card-actions">
              <div className="btn-group">
                <button 
                  type="button" 
                  className="btn btn-outline"
                  onClick={openAddressModal}
                  disabled={!selectedCustomer}
                >
                  <OrderIcon name="edit" />
                  Editar
                </button>
                <button 
                  type="button" 
                  className="btn btn-outline"
                  onClick={() => {
                    if (!selectedCustomer) {
                      emitToast({ type: "warning", message: "Selecione um cliente para adicionar endereço." });
                      return;
                    }
                    openAddressModal();
                  }}
                  disabled={!selectedCustomer}
                >
                  <OrderIcon name="plus" />
                  Novo
                </button>
              </div>
            </div>
          </div>

          {/* Order Status Card */}
          <div className="modular-card status-card">
            <div className="card-header">
              <h3><OrderIcon name="status" /> Status do Pedido</h3>
              <span className="status-badge status-open">🕐 Em Andamento</span>
            </div>
            <div className="card-content">
              <div className="status-timeline">
                <div className="status-item active">
                  <div className="status-dot"></div>
                  <div className="status-text">
                    <div className="status-title">📝 Pedido Iniciado</div>
                    <div className="status-time">✅ Concluído • {new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}</div>
                  </div>
                </div>
                <div className="status-item">
                  <div className="status-dot"></div>
                  <div className="status-text">
                    <div className="status-title">👨‍🍳 Produção / Cozinha</div>
                    <div className="status-time">⏳ Aguardando itens</div>
                  </div>
                </div>
                <div className="status-item">
                  <div className="status-dot"></div>
                  <div className="status-text">
                    <div className="status-title">🔔 Pronto para Retirada</div>
                    <div className="status-time">⏳ Aguardando produção</div>
                  </div>
                </div>
                <div className="status-item">
                  <div className="status-dot"></div>
                  <div className="status-text">
                    <div className="status-title">🛵 Saiu para Entrega</div>
                    <div className="status-time">⏳ Aguardando preparo</div>
                  </div>
                </div>
                <div className="status-item">
                  <div className="status-dot"></div>
                  <div className="status-text">
                    <div className="status-title">✅ Pedido Finalizado</div>
                    <div className="status-time">⏳ Em andamento</div>
                  </div>
                </div>
              </div>
              
              <div className="scheduled-checkbox">
                <label style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer' }}>
                  <input type="checkbox" style={{ margin: 0 }} />
                  <span>⏰ Pedido Agendado</span>
                </label>
              </div>
              
              {/* Additional Status Info */}
              <div style={{ 
                marginTop: '16px', 
                padding: '12px', 
                background: 'var(--surface-2)', 
                borderRadius: 'var(--radius-sm)',
                fontSize: '12px',
                color: 'var(--ink-soft)'
              }}>
                <div style={{ marginBottom: '4px' }}>
                  <strong>Tempo estimado:</strong> {totalItems > 0 ? `${Math.max(20, totalItems * 8)} minutos` : 'A definir'}
                </div>
                <div>
                  <strong>Previsão de entrega:</strong> {new Date(Date.now() + Math.max(20, totalItems * 8) * 60000).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}
                </div>
              </div>
            </div>
            <div className="card-actions">
              <button 
                type="button" 
                className="btn btn-primary btn-block"
                onClick={openOrderStatusModal}
              >
                <OrderIcon name="status" />
                Gerenciar Status
              </button>
            </div>
          </div>

          {/* Additional Actions Card - Simplificado */}
          <div className="modular-card actions-card">
            <div className="card-header">
              <h3><OrderIcon name="options" /> Ações e Observações</h3>
              <span className="status-badge" style={{
                background: orderNotes ? "rgba(16, 185, 129, 0.1)" : "rgba(100, 116, 139, 0.1)",
                color: orderNotes ? "var(--success)" : "var(--muted)",
                borderColor: orderNotes ? "rgba(16, 185, 129, 0.2)" : "rgba(100, 116, 139, 0.2)"
              }}>
                {orderNotes ? "📝 Com obs." : "📝 Sem obs."}
              </span>
            </div>
            <div className="card-content">
              <div className="observation-field">
                <textarea
                  placeholder="📝 Adicione observações importantes do pedido aqui... Ex: sem cebola, ponto da massa, etc."
                  value={orderNotes}
                  onChange={(e) => setOrderNotes(e.target.value)}
                  className="field-input"
                  rows={3}
                  style={{ 
                    fontSize: '14px',
                    lineHeight: '1.5',
                    resize: 'vertical'
                  }}
                />
                <div style={{ 
                  fontSize: '11px', 
                  color: 'var(--muted)', 
                  marginTop: '4px',
                  textAlign: 'right'
                }}>
                  {orderNotes.length}/200 caracteres
                </div>
              </div>
              
              {/* Quick Actions */}
              <div style={{ 
                display: 'grid', 
                gridTemplateColumns: 'repeat(2, 1fr)', 
                gap: '12px',
                marginTop: '16px',
                padding: '12px',
                background: 'var(--surface-2)',
                borderRadius: 'var(--radius-sm)',
                fontSize: '12px'
              }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                  <span>🛒</span>
                  <span><strong>{totalItems}</strong> itens</span>
                </div>
                <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                  <span>💰</span>
                  <span><strong>{formatCurrency(total)}</strong> total</span>
                </div>
                <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                  <span>🕐</span>
                  <span><strong>{Math.max(20, totalItems * 8)} min</strong> prep.</span>
                </div>
                <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                  <span>🛵</span>
                  <span><strong>{orderType === "delivery" ? "Sim" : "Não"}</strong> delivery</span>
                </div>
              </div>
              
              {/* Action Buttons */}
              <div style={{ 
                display: 'flex', 
                gap: '8px',
                marginTop: '16px'
              }}>
                <button
                  type="button"
                  className="btn btn-ghost btn-sm"
                  onClick={openOrderItemsModal}
                >
                  <OrderIcon name="edit" />
                  Editar Itens
                </button>
                <button
                  type="button"
                  className="btn btn-ghost btn-sm"
                  onClick={openOrderOptionsModal}
                >
                  <OrderIcon name="options" />
                  Opções
                </button>
              </div>
            </div>
          </div>

          {/* MAIN ACTION BUTTONS - FLUXO PRINCIPAL */}
          <div className="orderform-main-actions">
            <div className="main-actions-container">
              <button
                type="button"
                className="btn btn-secondary btn-large"
                onClick={handleClose}
                disabled={isLoading}
              >
                <OrderIcon name="back" />
                Cancelar
              </button>
              
              <div className="main-actions-group">
                <button
                  type="button"
                  className="btn btn-outline btn-large"
                  onClick={() => setShowPaymentModal(true)}
                  disabled={isLoading || totalItems === 0}
                >
                  {isLoading ? (
                    <div className="btn-loader">
                      <div className="spinner"></div>
                    </div>
                  ) : (
                    <>
                      <OrderIcon name="payment" />
                      Formas de Pagamento
                    </>
                  )}
                </button>
                
                <button
                  type="button"
                  className="btn btn-primary btn-large btn-emphasis"
                  onClick={() => handleSubmit(null, { action: "save" })}
                  disabled={isLoading || totalItems === 0}
                >
                  {isLoading ? (
                    <div className="btn-loader">
                      <div className="spinner"></div>
                    </div>
                  ) : (
                    <>
                      <OrderIcon name="check" />
                      {isEditing ? "Atualizar Pedido" : "Finalizar Pedido"}
                    </>
                  )}
                </button>
              </div>
            </div>
          
          {/* Secondary actions */}
          <div className="orderform-secondary-actions">
            <button
              type="button"
              className="btn btn-ghost btn-sm"
              onClick={() => {
                const { draft } = buildDraft();
                if (draft) {
                  writeOrderDraftToStorage({ 
                    draft, 
                    timestamp: Date.now(),
                    version: '1.0'
                  });
                  emitToast({ 
                    type: "success", 
                    message: "Rascunho salvo com sucesso!",
                    duration: 3000
                  });
                } else {
                  emitToast({ 
                    type: "warning", 
                    message: "Não foi possível salvar o rascunho. Verifique os dados do pedido.",
                    duration: 4000
                  });
                }
              }}
              title="Salvar rascunho (Ctrl+S)"
            >
              <OrderIcon name="save" />
              Salvar Rascunho
            </button>
            
            <button
              type="button"
              className="btn btn-ghost btn-sm"
              onClick={() => handleSubmit(null, { action: "save_and_print" })}
              disabled={isLoading || totalItems === 0}
            >
              {isLoading ? (
                <div className="btn-loader">
                  <div className="spinner"></div>
                </div>
              ) : (
                <>
                  <OrderIcon name="print" />
                  Imprimir Pedido
                </>
              )}
            </button>
          </div>
        </div>

        {/* Hidden form submission */}
        <form
          style={{ display: 'none' }}
          onSubmit={(e) => handleSubmit(e, { action: "save" })}
        />
      </div>
      </div>

      {/* MODAL COMPONENTS */}
      {showOrderItemsModal && (
        <OrderItemsModal
          isOpen={true}
          onClose={() => setShowOrderItemsModal(false)}
          orderItems={orderItems}
          setOrderItems={setOrderItems}
          pizzaCatalog={pizzaCatalog}
          drinkCatalog={drinkCatalog}
          extraCatalog={extraCatalog}
          formatCurrency={formatCurrency}
          showPizzaModal={showPizzaModal}
          onEditItem={handleEditItem}
          setShowPizzaModal={handleShowPizzaModal}
          showDrinkModal={showDrinkModal}
          setShowDrinkModal={handleShowDrinkModal}
        />
      )}

      {showCustomerInfoModal && (
        <CustomerInfoModal
          isOpen={true}
          onClose={() => setShowCustomerInfoModal(false)}
          customerMode={customerMode}
          selectedCustomer={selectedCustomer}
          customers={customers}
          counterLabel={counterLabel}
          onCustomerChange={setSelectedCustomerId}
          onCustomerModeChange={setCustomerMode}
          onCounterLabelChange={setCounterLabel}
        />
      )}

      {showDeliveryAddressModal && (
        <DeliveryAddressModal
          isOpen={true}
          onClose={() => setShowDeliveryAddressModal(false)}
          activeCustomerAddress={activeCustomerAddress}
          customerAltAddresses={customerAltAddresses}
          selectedCustomerAddressId={selectedCustomerAddressId}
          onAddressChange={setSelectedCustomerAddressId}
          onNewAddress={handleNewAddress}
          storeAddress={storeAddress}
        />
      )}

      {showOrderStatusModal && (
        <OrderStatusModal
          isOpen={true}
          onClose={() => setShowOrderStatusModal(false)}
          status={status}
          onStatusChange={(newStatus) => {
            // Handle status change
          }}
        />
      )}

      {showPaymentModal && (
        <PaymentModal
          isOpen={true}
          onClose={() => setShowPaymentModal(false)}
          paymentMethod={paymentMethod}
          onPaymentMethodChange={setPaymentMethod}
          total={total}
          cashGiven={cashGiven}
          onCashGivenChange={setCashGiven}
          formatCurrency={formatCurrency}
        />
      )}

      {showOrderOptionsModal && (
        <OrderOptionsModal
          isOpen={true}
          onClose={() => setShowOrderOptionsModal(false)}
          orderType={orderType}
          onOrderTypeChange={setOrderType}
          discountType={discountType}
          discountValue={discountValue}
          onDiscountChange={setDiscountType}
          onDiscountValueChange={setDiscountValue}
          orderNotes={orderNotes}
          kitchenNotes={kitchenNotes}
          onOrderNotesChange={setOrderNotes}
          onKitchenNotesChange={setKitchenNotes}
        />
      )}

      {showCustomerHistoryModal && (
        <CustomerHistoryModal
          isOpen={true}
          onClose={() => setShowCustomerHistoryModal(false)}
          customer={selectedCustomer}
          orders={allOrders}
        />
      )}

      {/* Pizza Modal */}
      {showPizzaModal && (
        <Modal
          isOpen={showPizzaModal}
          onClose={handleClosePizzaModal}
          className="orderform-modal"
          size="lg"
        >
          <div className="modal-section">
            <div className="modal-section-title">Montar Pizza</div>
            
            {/* Tamanho, Quantidade e Borda */}
            <div className="modal-grid-3 pizza-config-grid">
              <div className="pizza-config-left">
                <div className="pizza-config-row">
                  <div className="pizza-config-block">
                    <div className="field-label">Tamanho</div>
                    <div className="field-pill-group">
                      <button
                        type="button"
                        className={"field-pill" + (size === "broto" ? " field-pill-active" : "")}
                        onClick={() => setSize("broto")}
                        disabled={!hasPizzas}
                      >
                        Broto
                      </button>
                      <button
                        type="button"
                        className={"field-pill" + (size === "grande" ? " field-pill-active" : "")}
                        onClick={() => setSize("grande")}
                        disabled={!hasPizzas}
                      >
                        Grande
                      </button>
                    </div>
                  </div>

                  <div className="pizza-config-block">
                    <div className="field-label">Quantidade</div>
                    <input
                      className="field-input"
                      type="number"
                      min="1"
                      value={quantity}
                      onChange={(e) => setQuantity(e.target.value)}
                      disabled={!hasPizzas}
                    />
                  </div>
                </div>

                <div className="pizza-flavor-compact">
                  <div className="field-label">Selecionar Sabores</div>

                  <div className="flavor-tabs-compact">
                    <button
                      type="button"
                      className={"flavor-tab-compact" + (activeFlavorSlot === "flavor1" ? " active" : "")}
                      onClick={() => setActiveFlavorSlot("flavor1")}
                    >
                      <span className="flavor-tab-number">1</span>
                      <span className="flavor-tab-text">
                        {flavor1Pizza?.name || "1º Sabor"}
                      </span>
                    </button>
                    {(twoFlavorsEnabled || threeFlavorsEnabled) && (
                      <button
                        type="button"
                        className={"flavor-tab-compact" + (activeFlavorSlot === "flavor2" ? " active" : "")}
                        onClick={() => setActiveFlavorSlot("flavor2")}
                      >
                        <span className="flavor-tab-number">2</span>
                        <span className="flavor-tab-text">
                          {flavor2Pizza?.name || "2º Sabor"}
                        </span>
                      </button>
                    )}
                    {threeFlavorsEnabled && (
                      <button
                        type="button"
                        className={"flavor-tab-compact" + (activeFlavorSlot === "flavor3" ? " active" : "")}
                        onClick={() => setActiveFlavorSlot("flavor3")}
                      >
                        <span className="flavor-tab-number">3</span>
                        <span className="flavor-tab-text">
                          {flavor3Pizza?.name || "3º Sabor"}
                        </span>
                      </button>
                    )}
                  </div>

                  <div className="field-input-with-icon">
                    <input
                      className="field-input"
                      value={flavorSearch}
                      onChange={(e) => setFlavorSearch(e.target.value)}
                      placeholder="Buscar sabores..."
                      disabled={!hasPizzas}
                    />
                  </div>

                </div>
                {/* Quantidade de Sabores */}
                <div className="pizza-flavor-mode">
                  <div className="field-label">Sabores</div>
                  <div className="field-pill-group">
                    <button
                      type="button"
                      className={"field-pill" + (!twoFlavorsEnabled && !threeFlavorsEnabled ? " field-pill-active" : "")}
                      onClick={() => {
                        setTwoFlavorsEnabled(false);
                        setThreeFlavorsEnabled(false);
                        setFlavor2("");
                        setFlavor3("");
                      }}
                      disabled={!hasPizzas}
                    >
                      1 Sabor
                    </button>
                    <button
                      type="button"
                      className={"field-pill" + (twoFlavorsEnabled && !threeFlavorsEnabled ? " field-pill-active" : "")}
                      onClick={() => {
                        setTwoFlavorsEnabled(true);
                        setThreeFlavorsEnabled(false);
                        setFlavor3("");
                      }}
                      disabled={!hasPizzas}
                    >
                      2 Sabores
                    </button>
                    <button
                      type="button"
                      className={"field-pill" + (threeFlavorsEnabled ? " field-pill-active" : "")}
                      onClick={() => {
                        setTwoFlavorsEnabled(false);
                        setThreeFlavorsEnabled(true);
                      }}
                      disabled={!hasPizzas}
                    >
                      3 Sabores
                    </button>
                  </div>
                </div>

                {/* Resumo da Pizza */}
                <div className="pizza-summary-section">
                  <div className="field-label">Resumo</div>
                  <div className="pizza-summary">
                    <div className="summary-chips">
                      <span className="chip chip-soft">
                        {quantity || 1}x {size === "broto" ? "Broto" : "Grande"}
                      </span>
                      <span className="chip chip-outline">
                        Borda: {pizzaCrusts.find(c => c.id === selectedCrust)?.name || "Tradicional"}
                      </span>
                      {flavor1 && (
                        <span className="chip">
                          1º: {flavor1Pizza?.name || "Selecionado"}
                        </span>
                      )}
                      {twoFlavorsEnabled && flavor2 && (
                        <span className="chip chip-alt">
                          2º: {flavor2Pizza?.name || "Selecionado"}
                        </span>
                      )}
                      {threeFlavorsEnabled && flavor3 && (
                        <span className="chip chip-alt">
                          3º: {flavor3Pizza?.name || "Selecionado"}
                        </span>
                      )}
                      {selectedExtras.length > 0 && (
                        <span className="chip chip-soft">
                          +{selectedExtras.length} ingredientes
                        </span>
                      )}
                    </div>
                    <div className="summary-price">
                      Unitário: <strong>{formatCurrency(unitPizzaPrice)}</strong>
                    </div>
                  </div>
                </div>

                {/* Seleção de Sabores */}
                <div className="pizza-flavor-selection">
                  <div className="field-label">Sabores disponíveis</div>

                  <div className="pizza-cards-grid">
                    {!hasPizzas ? (
                      <div className="empty small">Nenhuma pizza cadastrada.</div>
                    ) : filteredPizzas.length === 0 ? (
                      <div className="empty small">Nenhum sabor encontrado.</div>
                    ) : (
                      filteredPizzas.map((p) => {
                        const isSelected =
                          String(p.id) === String(flavor1) ||
                          String(p.id) === String(flavor2) ||
                          String(p.id) === String(flavor3);

                        const price = p.prices[size] || p.prices.grande || p.prices.broto || 0;

                        return (
                          <button
                            key={p.id}
                            type="button"
                            className={"pizza-card" + (isSelected ? " pizza-card-selected" : "")}
                            onClick={() => handleSelectFlavorCard(p.id)}
                            disabled={!hasPizzas}
                          >
                            <div className="pizza-card-header">
                              <div className="pizza-card-name">{p.name}</div>
                              <div className="pizza-card-price">{formatCurrency(price)}</div>
                            </div>
                            {p.categoria && (
                              <div className="pizza-card-badge">{p.categoria}</div>
                            )}
                            {p.description && (
                              <div className="pizza-card-desc">{p.description}</div>
                            )}
                            {isSelected && (
                              <div className="pizza-card-flavor-tags">
                                {String(p.id) === String(flavor1) && <span className="chip chip-soft">1º</span>}
                                {String(p.id) === String(flavor2) && <span className="chip chip-soft">2º</span>}
                                {String(p.id) === String(flavor3) && <span className="chip chip-soft">3º</span>}
                              </div>
                            )}
                          </button>
                        );
                      })
                    )}
                  </div>
                </div>

              </div>

              <div className="crust-selection">
                <div className="field-label">Borda</div>
                <div className="field-pill-group">
                  {pizzaCrusts.map((crust) => (
                    <button
                      key={crust.id}
                      type="button"
                      className={"field-pill" + (selectedCrust === crust.id ? " field-pill-active" : "")}
                      onClick={() => setSelectedCrust(crust.id)}
                      disabled={!hasPizzas}
                    >
                      {crust.name}
                      {crust.price > 0 && (
                        <span className="crust-price">+{formatCurrency(crust.price)}</span>
                      )}
                    </button>
                  ))}
                </div>
              </div>
            </div>

            {/* Ingredientes Extras (do catálogo de pizzas) */}
            <div className="pizza-extras-section">
              <div className="pizza-extras-header">
                <div className="field-label">Ingredientes Extras</div>
                {pizzaIngredients.length > 0 && (
                  <button
                    type="button"
                    className={"extras-toggle-chip" + (extrasOpen ? " extras-toggle-chip-on" : "")}
                    onClick={() => setExtrasOpen(!extrasOpen)}
                    disabled={!hasPizzas}
                  >
                    <span className="extras-toggle-thumb" />
                    <span className="extras-toggle-label">
                      {extrasOpen ? "Esconder Extras" : "Mostrar Extras"}
                    </span>
                  </button>
                )}
              </div>

              {!pizzaIngredients.length ? (
                <div className="empty small">Nenhum ingrediente extra disponível.</div>
              ) : extrasOpen && (
                <div className="extras-grid">
                  {pizzaIngredients.map((ingredient, index) => {
                    const checked = selectedExtras.includes(`ingredient_${index}`);
                    const price = ingredient.basePrice;
                    
                    return (
                      <label key={`ingredient_${index}`} className={"extra-item" + (checked ? " extra-item-selected" : "")}>
                        <input
                          type="checkbox"
                          checked={checked}
                          onChange={() => handleToggleExtra(`ingredient_${index}`)}
                          disabled={!hasPizzas}
                        />
                        <div className="extra-item-content">
                          <span className="extra-item-name">{ingredient.name}</span>
                          <span className="extra-item-price">+ {formatCurrency(price)}</span>
                        </div>
                      </label>
                    );
                  })}
                </div>
              )}
            </div>

            {/* Observações Pré-definidas */}
            <div className="pizza-notes-section">
              <div className="field-label">Observações Rápidas</div>
              <div className="quick-notes-grid">
                {[
                  "Sem cebola",
                  "Sem tomate", 
                  "Sem azeitona",
                  "Bem passada",
                  "Ao ponto",
                  "Extra queijo",
                  "Extra bacon",
                  "Sem pimenta"
                ].map((note) => (
                  <button
                    key={note}
                    type="button"
                    className="quick-note-btn"
                    onClick={() => {
                      const currentNotes = orderNotes || "";
                      const newNotes = currentNotes 
                        ? currentNotes + ", " + note.toLowerCase()
                        : note.toLowerCase();
                      setOrderNotes(newNotes);
                    }}
                  >
                    {note}
                  </button>
                ))}
              </div>
            </div>

          </div>

          <div className="modal-footer">
            <button 
              type="button" 
              className="btn btn-outline" 
              onClick={handleClosePizzaModal}
            >
              Cancelar
            </button>
            <button
              type="button"
              className="btn btn-primary"
              onClick={() => {
                const added = handleAddPizza();
                if (added) {
                  handleClosePizzaModal();
                }
              }}
              disabled={!hasPizzas || isLoading}
            >
              Adicionar ao Pedido
            </button>
          </div>
        </Modal>
      )}

      {/* Drink Modal */}
      {showDrinkModal && (
        <Modal
          isOpen={showDrinkModal}
          onClose={handleCloseDrinkModal}
          className="orderform-modal"
          size="md"
        >
          <div className="modal-section">
            <div className="modal-section-title">Adicionar Bebida</div>

            <div className="field-label">Buscar bebida</div>
            <div className="field-input-with-icon">
              <input
                className="field-input"
                value={drinkSearch}
                onChange={(e) => setDrinkSearch(e.target.value)}
                placeholder="Buscar bebida..."
                disabled={!drinkCatalog.length}
              />
            </div>

            <div className="items-grid">
              {filteredDrinks.length ? (
                filteredDrinks.map((drink) => {
                  const price =
                    drink?.prices?.grande || drink?.prices?.broto || 0;
                  const isSelected = String(selectedDrinkId) === String(drink.id);
                  return (
                    <button
                      key={drink.id}
                      type="button"
                      className={`item-card ${isSelected ? "is-selected" : ""}`}
                      onClick={() => setSelectedDrinkId(drink.id)}
                    >
                      <div className="item-header">
                        <div className="item-title">
                          {drink.name || "Bebida"}
                        </div>
                        <div className="item-price">
                          {formatCurrency(price)}
                        </div>
                      </div>
                      {drink.description && (
                        <div className="item-details">{drink.description}</div>
                      )}
                    </button>
                  );
                })
              ) : (
                <div className="modal-notice modal-notice--warning">
                  <span className="modal-notice__icon">ƒsÿ</span>
                  Nenhuma bebida encontrada.
                </div>
              )}
            </div>

            <div className="modal-section-footer">
              <div className="field-label">Quantidade</div>
              <input
                className="field-input"
                type="number"
                min="1"
                value={drinkQuantity}
                onChange={(e) => setDrinkQuantity(e.target.value)}
                disabled={!drinkCatalog.length}
              />
              <button
                type="button"
                className="btn btn-outline"
                onClick={handleCloseDrinkModal}
              >
                Cancelar
              </button>
              <button
                type="button"
                className="btn btn-primary"
                onClick={() => {
                  const added = handleAddDrink();
                  if (added) {
                    handleCloseDrinkModal();
                  }
                }}
                disabled={!drinkCatalog.length}
              >
                Adicionar bebida
              </button>
            </div>
          </div>
        </Modal>
      )}
    </>
  );
}
